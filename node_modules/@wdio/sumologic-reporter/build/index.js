// src/index.ts
import dateFormat from "dateformat";
import stringify from "json-stringify-safe";
import WDIOReporter from "@wdio/reporter";
import logger from "@wdio/logger";
var log = logger("@wdio/sumologic-reporter");
var MAX_LINES = 100;
var DATE_FORMAT = "yyyy-mm-dd HH:mm:ss,l o";
var SumoLogicReporter = class extends WDIOReporter {
  _options;
  _interval;
  _unsynced = [];
  _isSynchronising = false;
  _hasRunnerEnd = false;
  constructor(options) {
    super(options);
    this._options = Object.assign({
      // don't create a log file
      stdout: true,
      // define sync interval how often logs get pushed to Sumologic
      syncInterval: 100,
      // endpoint of collector source
      sourceAddress: process.env.SUMO_SOURCE_ADDRESS
    }, options);
    if (typeof this._options.sourceAddress !== "string") {
      log.error('Sumo Logic requires "sourceAddress" paramater');
    }
    this._interval = global.setInterval(this.sync.bind(this), this._options.syncInterval);
  }
  // @ts-ignore
  get isSynchronised() {
    return this._unsynced.length === 0;
  }
  onRunnerStart(runner) {
    this._unsynced.push(stringify({
      time: dateFormat(/* @__PURE__ */ new Date(), DATE_FORMAT),
      event: "runner:start",
      data: runner
    }));
  }
  onSuiteStart(suite) {
    this._unsynced.push(stringify({
      time: dateFormat(/* @__PURE__ */ new Date(), DATE_FORMAT),
      event: "suite:start",
      data: suite
    }));
  }
  onTestStart(test) {
    this._unsynced.push(stringify({
      time: dateFormat(/* @__PURE__ */ new Date(), DATE_FORMAT),
      event: "test:start",
      data: test
    }));
  }
  onTestSkip(test) {
    this._unsynced.push(stringify({
      time: dateFormat(/* @__PURE__ */ new Date(), DATE_FORMAT),
      event: "test:skip",
      data: test
    }));
  }
  onTestPass(test) {
    this._unsynced.push(stringify({
      time: dateFormat(/* @__PURE__ */ new Date(), DATE_FORMAT),
      event: "test:pass",
      data: test
    }));
  }
  onTestFail(test) {
    this._unsynced.push(stringify({
      time: dateFormat(/* @__PURE__ */ new Date(), DATE_FORMAT),
      event: "test:fail",
      data: test
    }));
  }
  onTestEnd(test) {
    this._unsynced.push(stringify({
      time: dateFormat(/* @__PURE__ */ new Date(), DATE_FORMAT),
      event: "test:end",
      data: test
    }));
  }
  onSuiteEnd(suite) {
    this._unsynced.push(stringify({
      time: dateFormat(/* @__PURE__ */ new Date(), DATE_FORMAT),
      event: "suite:end",
      data: suite
    }));
  }
  onRunnerEnd(runner) {
    this._hasRunnerEnd = true;
    this._unsynced.push(stringify({
      time: dateFormat(/* @__PURE__ */ new Date(), DATE_FORMAT),
      event: "runner:end",
      data: runner
    }));
  }
  async sync() {
    if (this._hasRunnerEnd && this._unsynced.length === 0) {
      clearInterval(this._interval);
    }
    if (this._isSynchronising || this._unsynced.length === 0 || typeof this._options.sourceAddress !== "string") {
      return;
    }
    const logLines = this._unsynced.slice(0, MAX_LINES).join("\n");
    this._isSynchronising = true;
    log.debug("start synchronization");
    try {
      const resp = await fetch(this._options.sourceAddress, {
        method: "POST",
        body: JSON.stringify(logLines)
      });
      this._unsynced.splice(0, MAX_LINES);
      this._isSynchronising = false;
      return log.debug(`synchronised collector data, server status: ${resp.status}`);
    } catch (err) {
      return log.error("failed send data to Sumo Logic:\n", err.stack);
    }
  }
};
export {
  SumoLogicReporter as default
};
