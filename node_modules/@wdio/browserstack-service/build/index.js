var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/launcher.ts
import { FormData as FormData2 } from "formdata-node";
import { v4 as uuidv4 } from "uuid";
import fs11 from "node:fs";
import path11 from "node:path";
import { promisify as promisify2, format } from "node:util";
import { performance as performance2, PerformanceObserver as PerformanceObserver2 } from "node:perf_hooks";
import os5 from "node:os";
import { SevereServiceError } from "webdriverio";
import * as BrowserstackLocalLauncher from "browserstack-local";

// src/performance-tester.ts
import { createObjectCsvWriter } from "csv-writer";
import fs4 from "node:fs";
import { performance, PerformanceObserver } from "node:perf_hooks";

// src/util.ts
import { hostname, platform, type, version, arch } from "node:os";
import fs3 from "node:fs";
import zlib from "node:zlib";
import { promisify } from "node:util";
import path3 from "node:path";
import util from "node:util";
import gitRepoInfo from "git-repo-info";
import gitconfig from "gitconfiglocal";
import { FormData } from "formdata-node";

// src/logPatcher.ts
import Transport from "winston-transport";
var LOG_LEVELS = {
  INFO: "INFO",
  ERROR: "ERROR",
  DEBUG: "DEBUG",
  TRACE: "TRACE",
  WARN: "WARN"
};
var logPatcher = class extends Transport {
  constructor(opts) {
    super(opts);
  }
  logToTestOps = (level = LOG_LEVELS.INFO, message = [""]) => {
    process.emit(`bs:addLog:${process.pid}`, {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      level: level.toUpperCase(),
      message: `"${message.join(", ")}"`,
      kind: "TEST_LOG",
      http_response: {}
    });
  };
  /* Patching this would show user an extended trace on their cli */
  trace = (...message) => {
    this.logToTestOps(LOG_LEVELS.TRACE, message);
  };
  debug = (...message) => {
    this.logToTestOps(LOG_LEVELS.DEBUG, message);
  };
  info = (...message) => {
    this.logToTestOps(LOG_LEVELS.INFO, message);
  };
  warn = (...message) => {
    this.logToTestOps(LOG_LEVELS.WARN, message);
  };
  error = (...message) => {
    this.logToTestOps(LOG_LEVELS.ERROR, message);
  };
  log = (...message) => {
    this.logToTestOps(LOG_LEVELS.INFO, message);
  };
};
var logPatcher_default = logPatcher;

// package.json
var package_default = {
  name: "@wdio/browserstack-service",
  version: "9.2.0",
  description: "WebdriverIO service for better Browserstack integration",
  author: "Adam Bjerstedt <abjerstedt@gmail.com>",
  homepage: "https://github.com/webdriverio/webdriverio/tree/main/packages/wdio-browserstack-service",
  license: "MIT",
  engines: {
    node: ">=18.20.0"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/webdriverio/webdriverio.git",
    directory: "packages/wdio-browserstack-service"
  },
  keywords: [
    "webdriverio",
    "wdio",
    "browserstack",
    "wdio-service"
  ],
  bugs: {
    url: "https://github.com/webdriverio/webdriverio/issues"
  },
  type: "module",
  types: "./build/index.d.ts",
  exports: {
    ".": {
      types: "./build/index.d.ts",
      import: "./build/index.js"
    }
  },
  typeScriptVersion: "3.8.3",
  dependencies: {
    "@browserstack/ai-sdk-node": "1.5.9",
    "@percy/appium-app": "^2.0.1",
    "@percy/selenium-webdriver": "^2.0.3",
    "@types/gitconfiglocal": "^2.0.1",
    "@wdio/logger": "workspace:*",
    "@wdio/reporter": "workspace:*",
    "@wdio/types": "workspace:*",
    "browserstack-local": "^1.5.1",
    chalk: "^5.3.0",
    "csv-writer": "^1.6.0",
    "formdata-node": "5.0.1",
    "git-repo-info": "^2.1.1",
    gitconfiglocal: "^2.1.0",
    uuid: "^10.0.0",
    webdriverio: "workspace:*",
    "winston-transport": "^4.5.0",
    yauzl: "^3.0.0"
  },
  peerDependencies: {
    "@wdio/cli": "^5.0.0 || ^6.0.0 || ^7.0.0 || ^8.0.0 || ^9.0.0"
  },
  devDependencies: {
    "@types/node": "^20.1.0",
    "@types/yauzl": "^2.10.3",
    "@wdio/globals": "workspace:*"
  },
  publishConfig: {
    access: "public"
  }
};

// src/constants.ts
var bstackServiceVersion = package_default.version;
var BROWSER_DESCRIPTION = [
  "device",
  "os",
  "osVersion",
  "os_version",
  "browserName",
  "browser",
  "browserVersion",
  "browser_version"
];
var VALID_APP_EXTENSION = [
  ".apk",
  ".aab",
  ".ipa"
];
var DEFAULT_OPTIONS = {
  setSessionName: true,
  setSessionStatus: true,
  testObservability: true,
  accessibility: false
};
var consoleHolder = Object.assign({}, console);
var DATA_ENDPOINT = "https://collector-observability.browserstack.com";
var DATA_EVENT_ENDPOINT = "api/v1/event";
var DATA_BATCH_ENDPOINT = "api/v1/batch";
var DATA_SCREENSHOT_ENDPOINT = "api/v1/screenshots";
var DATA_BATCH_SIZE = 1e3;
var DATA_BATCH_INTERVAL = 2e3;
var DEFAULT_WAIT_TIMEOUT_FOR_PENDING_UPLOADS = 5e3;
var DEFAULT_WAIT_INTERVAL_FOR_PENDING_UPLOADS = 100;
var BSTACK_SERVICE_VERSION = bstackServiceVersion;
var ACCESSIBILITY_API_URL = "https://accessibility.browserstack.com/api";
var NOT_ALLOWED_KEYS_IN_CAPS = ["includeTagsInTestingScope", "excludeTagsInTestingScope"];
var LOGS_FILE = "logs/bstack-wdio-service.log";
var UPLOAD_LOGS_ADDRESS = "https://upload-observability.browserstack.com";
var UPLOAD_LOGS_ENDPOINT = "client-logs/upload";
var PERCY_LOGS_FILE = "logs/percy.log";
var PERCY_DOM_CHANGING_COMMANDS_ENDPOINTS = [
  "/session/:sessionId/url",
  "/session/:sessionId/forward",
  "/session/:sessionId/back",
  "/session/:sessionId/refresh",
  "/session/:sessionId/screenshot",
  "/session/:sessionId/actions",
  "/session/:sessionId/appium/device/shake"
];
var CAPTURE_MODES = ["click", "auto", "screenshot", "manual", "testcase"];
var LOG_KIND_USAGE_MAP = {
  "TEST_LOG": "log",
  "TEST_SCREENSHOT": "screenshot",
  "TEST_STEP": "step",
  "HTTP": "http"
};
var FUNNEL_INSTRUMENTATION_URL = "https://api.browserstack.com/sdk/v1/event";
var SUPPORTED_BROWSERS_FOR_AI = ["chrome", "microsoftedge", "firefox"];
var TCG_URL = "https://tcg.browserstack.com";
var TCG_INFO = {
  tcgRegion: "use",
  tcgUrl: TCG_URL
};
var TESTOPS_JWT_ENV = "BS_TESTOPS_JWT";
var BSTACK_TCG_AUTH_RESULT = "BSTACK_TCG_AUTH_RESULT";
var TESTOPS_SCREENSHOT_ENV = "BS_TESTOPS_ALLOW_SCREENSHOTS";
var TESTOPS_BUILD_ID_ENV = "BS_TESTOPS_BUILD_HASHED_ID";
var PERF_MEASUREMENT_ENV = "BROWSERSTACK_O11Y_PERF_MEASUREMENT";
var RERUN_TESTS_ENV = "BROWSERSTACK_RERUN_TESTS";
var RERUN_ENV = "BROWSERSTACK_RERUN";
var TESTOPS_BUILD_COMPLETED_ENV = "BS_TESTOPS_BUILD_COMPLETED";
var MAX_GIT_META_DATA_SIZE_IN_BYTES = 64 * 1024;
var GIT_META_DATA_TRUNCATED = "...[TRUNCATED]";

// src/bstackLogger.ts
import path from "node:path";
import fs from "node:fs";
import chalk from "chalk";
import logger from "@wdio/logger";
var log = logger("@wdio/browserstack-service");
var BStackLogger = class {
  static logFilePath = path.join(process.cwd(), LOGS_FILE);
  static logFolderPath = path.join(process.cwd(), "logs");
  static logFileStream;
  static logToFile(logMessage, logLevel) {
    try {
      if (!this.logFileStream) {
        this.ensureLogsFolder();
        this.logFileStream = fs.createWriteStream(this.logFilePath, { flags: "a" });
      }
      if (this.logFileStream && this.logFileStream.writable) {
        this.logFileStream.write(this.formatLog(logMessage, logLevel));
      }
    } catch (error) {
      log.debug(`Failed to log to file. Error ${error}`);
    }
  }
  static formatLog(logMessage, level) {
    return `${chalk.gray((/* @__PURE__ */ new Date()).toISOString())} ${chalk[COLORS[level]](level.toUpperCase())} ${chalk.whiteBright("@wdio/browserstack-service")} ${logMessage}
`;
  }
  static info(message) {
    this.logToFile(message, "info");
    log.info(message);
  }
  static error(message) {
    this.logToFile(message, "error");
    log.error(message);
  }
  static debug(message, param) {
    this.logToFile(message, "debug");
    if (param) {
      log.debug(message, param);
    } else {
      log.debug(message);
    }
  }
  static warn(message) {
    this.logToFile(message, "warn");
    log.warn(message);
  }
  static trace(message) {
    this.logToFile(message, "trace");
    log.trace(message);
  }
  static clearLogger() {
    if (this.logFileStream) {
      this.logFileStream.end();
    }
    this.logFileStream = null;
  }
  static clearLogFile() {
    if (fs.existsSync(this.logFilePath)) {
      fs.truncateSync(this.logFilePath);
    }
  }
  static ensureLogsFolder() {
    if (!fs.existsSync(this.logFolderPath)) {
      fs.mkdirSync(this.logFolderPath);
    }
  }
};

// src/crash-reporter.ts
var CrashReporter = class {
  /* User test config for build run minus PII */
  static userConfigForReporting = {};
  /* User credentials used for reporting crashes in browserstack service */
  static credentialsForCrashReportUpload = {};
  static setCredentialsForCrashReportUpload(options, config) {
    this.credentialsForCrashReportUpload = {
      username: getObservabilityUser(options, config),
      password: getObservabilityKey(options, config)
    };
    process.env.CREDENTIALS_FOR_CRASH_REPORTING = JSON.stringify(this.credentialsForCrashReportUpload);
  }
  static setConfigDetails(userConfig, capabilities, options) {
    const configWithoutPII = this.filterPII(userConfig);
    const filteredCapabilities = this.filterCapabilities(capabilities);
    this.userConfigForReporting = {
      framework: userConfig.framework,
      services: configWithoutPII.services,
      capabilities: filteredCapabilities,
      env: {
        "BROWSERSTACK_BUILD": process.env.BROWSERSTACK_BUILD,
        "BROWSERSTACK_BUILD_NAME": process.env.BROWSERSTACK_BUILD_NAME,
        "BUILD_TAG": process.env.BUILD_TAG
      }
    };
    process.env.USER_CONFIG_FOR_REPORTING = JSON.stringify(this.userConfigForReporting);
    this.setCredentialsForCrashReportUpload(options, userConfig);
  }
  static async uploadCrashReport(exception, stackTrace) {
    try {
      if (!this.credentialsForCrashReportUpload.username || !this.credentialsForCrashReportUpload.password) {
        this.credentialsForCrashReportUpload = process.env.CREDENTIALS_FOR_CRASH_REPORTING !== void 0 ? JSON.parse(process.env.CREDENTIALS_FOR_CRASH_REPORTING) : this.credentialsForCrashReportUpload;
      }
    } catch (error) {
      return BStackLogger.error(`[Crash_Report_Upload] Failed to parse user credentials while reporting crash due to ${error}`);
    }
    if (!this.credentialsForCrashReportUpload.username || !this.credentialsForCrashReportUpload.password) {
      return BStackLogger.error("[Crash_Report_Upload] Failed to parse user credentials while reporting crash");
    }
    try {
      if (Object.keys(this.userConfigForReporting).length === 0) {
        this.userConfigForReporting = process.env.USER_CONFIG_FOR_REPORTING !== void 0 ? JSON.parse(process.env.USER_CONFIG_FOR_REPORTING) : {};
      }
    } catch (error) {
      BStackLogger.error(`[Crash_Report_Upload] Failed to parse user config while reporting crash due to ${error}`);
      this.userConfigForReporting = {};
    }
    const data = {
      hashed_id: process.env[TESTOPS_BUILD_ID_ENV],
      observability_version: {
        frameworkName: "WebdriverIO-" + (this.userConfigForReporting.framework || "null"),
        sdkVersion: BSTACK_SERVICE_VERSION
      },
      exception: {
        error: exception.toString(),
        stackTrace
      },
      config: this.userConfigForReporting
    };
    const url3 = `${DATA_ENDPOINT}/api/v1/analytics`;
    const encodedAuth = Buffer.from(`${this.credentialsForCrashReportUpload.username}:${this.credentialsForCrashReportUpload.password}`, "utf8").toString("base64");
    const headers = {
      ...DEFAULT_REQUEST_CONFIG.headers,
      Authorization: `Basic ${encodedAuth}`
    };
    const response = await fetch(url3, {
      method: "POST",
      body: JSON.stringify(data),
      headers
    });
    if (response.ok) {
      BStackLogger.debug(`[Crash_Report_Upload] Success response: ${JSON.stringify(await response.json())}`);
    } else {
      BStackLogger.error(`[Crash_Report_Upload] Failed due to ${response.body}`);
    }
  }
  static recursivelyRedactKeysFromObject(obj, keys) {
    if (!obj) {
      return;
    }
    if (Array.isArray(obj)) {
      obj.map((ele) => this.recursivelyRedactKeysFromObject(ele, keys));
    } else {
      for (const prop in obj) {
        if (keys.includes(prop.toLowerCase())) {
          obj[prop] = "[REDACTED]";
        } else if (typeof obj[prop] === "object") {
          this.recursivelyRedactKeysFromObject(obj[prop], keys);
        }
      }
    }
  }
  static deletePIIKeysFromObject(obj) {
    if (!obj) {
      return;
    }
    ["user", "username", "key", "accessKey"].forEach((key) => delete obj[key]);
  }
  static filterCapabilities(capabilities) {
    const capsCopy = JSON.parse(JSON.stringify(capabilities));
    this.recursivelyRedactKeysFromObject(capsCopy, ["extensions"]);
    return capsCopy;
  }
  static filterPII(userConfig) {
    const configWithoutPII = JSON.parse(JSON.stringify(userConfig));
    this.deletePIIKeysFromObject(configWithoutPII);
    const finalServices = [];
    const initialServices = configWithoutPII.services;
    delete configWithoutPII.services;
    try {
      for (const serviceArray of initialServices) {
        if (Array.isArray(serviceArray) && serviceArray.length >= 2 && serviceArray[0] === "browserstack") {
          for (let idx = 1; idx < serviceArray.length; idx++) {
            this.deletePIIKeysFromObject(serviceArray[idx]);
            serviceArray[idx] && this.deletePIIKeysFromObject(serviceArray[idx].testObservabilityOptions);
          }
          finalServices.push(serviceArray);
          break;
        }
      }
    } catch (err) {
      BStackLogger.error(`Error in parsing user config PII with error ${err ? err.stack || err : err}`);
      return configWithoutPII;
    }
    configWithoutPII.services = finalServices;
    return configWithoutPII;
  }
};

// src/fileStream.ts
var FileStream = class {
  readableStream;
  constructor(readableStream) {
    this.readableStream = readableStream;
  }
  stream() {
    return this.readableStream;
  }
  get [Symbol.toStringTag]() {
    return "File";
  }
};

// src/testOps/featureStats.ts
var FeatureStats = class _FeatureStats {
  triggeredCount = 0;
  sentCount = 0;
  failedCount = 0;
  groups = {};
  mark(status, groupId) {
    switch (status) {
      case "triggered":
        this.triggered(groupId);
        break;
      case "success":
      case "sent":
        this.sent(groupId);
        break;
      case "failed":
        this.failed(groupId);
        break;
      default:
        BStackLogger.debug("Request to mark usage for unknown status - " + status);
        break;
    }
  }
  triggered(groupId) {
    this.triggeredCount += 1;
    if (groupId) {
      this.createGroup(groupId).triggered();
    }
  }
  sent(groupId) {
    this.sentCount += 1;
    if (groupId) {
      this.createGroup(groupId).sent();
    }
  }
  failed(groupId) {
    this.failedCount += 1;
    if (groupId) {
      this.createGroup(groupId).failed();
    }
  }
  success(groupId) {
    this.sent(groupId);
  }
  createGroup(groupId) {
    if (!this.groups[groupId]) {
      this.groups[groupId] = new _FeatureStats();
    }
    return this.groups[groupId];
  }
  getTriggeredCount() {
    return this.triggeredCount;
  }
  getSentCount() {
    return this.sentCount;
  }
  getFailedCount() {
    return this.failedCount;
  }
  getUsageForGroup(groupId) {
    return this.groups[groupId] || new _FeatureStats();
  }
  getOverview() {
    return { triggeredCount: this.triggeredCount, sentCount: this.sentCount, failedCount: this.failedCount };
  }
  getGroups() {
    return this.groups;
  }
  add(featureStats) {
    this.triggeredCount += featureStats.getTriggeredCount();
    this.sentCount += featureStats.getSentCount();
    this.failedCount += featureStats.getFailedCount();
    Object.entries(featureStats.getGroups()).forEach(([groupId, group]) => {
      this.createGroup(groupId).add(group);
    });
  }
  // omitGroups: true/false -> Include groups or not
  // onlyGroups: true/false -> data includes only groups
  // nestedGroups: true/false -> groups will be nested in groups if true
  toJSON(config = {}) {
    const overviewData = !config.onlyGroups ? {
      triggeredCount: this.triggeredCount,
      sentCount: this.sentCount,
      failedCount: this.failedCount
    } : {};
    const groupsData = {};
    if (!config.omitGroups) {
      Object.entries(this.groups).forEach(([groupId, group2]) => {
        groupsData[groupId] = group2.toJSON();
      });
    }
    const group = config.nestedGroups ? { groups: groupsData } : groupsData;
    return {
      ...overviewData,
      ...group
    };
  }
  static fromJSON(json) {
    const stats = new _FeatureStats();
    if (!json || isObjectEmpty(json)) {
      return stats;
    }
    stats.triggeredCount = json.triggeredCount;
    stats.sentCount = json.sentCount;
    stats.failedCount = json.failedCount;
    if (!json.groups) {
      return stats;
    }
    Object.entries(json.groups).forEach(([groupId, group]) => {
      stats.groups[groupId] = _FeatureStats.fromJSON(group);
    });
    return stats;
  }
};
var featureStats_default = FeatureStats;

// src/testOps/featureUsage.ts
var FeatureUsage = class {
  isTriggered;
  status;
  error;
  constructor(isTriggered) {
    if (isTriggered !== void 0) {
      this.isTriggered = isTriggered;
    }
  }
  getTriggered() {
    return this.isTriggered;
  }
  setTriggered(triggered) {
    this.isTriggered = triggered;
  }
  setStatus(status) {
    this.status = status;
  }
  setError(error) {
    this.error = error;
  }
  triggered() {
    this.isTriggered = true;
  }
  failed(e) {
    this.status = "failed";
    this.error = getErrorString(e);
  }
  success() {
    this.status = "success";
  }
  getStatus() {
    return this.status;
  }
  getError() {
    return this.error;
  }
  toJSON() {
    return {
      isTriggered: this.isTriggered,
      status: this.status,
      error: this.error
    };
  }
};
var featureUsage_default = FeatureUsage;

// src/testOps/testOpsConfig.ts
var TestOpsConfig = class _TestOpsConfig {
  constructor(enabled = true, manuallySet = false) {
    this.enabled = enabled;
    this.manuallySet = manuallySet;
    _TestOpsConfig._instance = this;
  }
  static _instance;
  buildStopped = false;
  buildHashedId;
  static getInstance(...args) {
    if (!this._instance) {
      this._instance = new _TestOpsConfig(...args);
    }
    return this._instance;
  }
};
var testOpsConfig_default = TestOpsConfig;

// src/testOps/usageStats.ts
var UsageStats = class _UsageStats {
  static instance;
  testStartedStats;
  testFinishedStats;
  hookStartedStats;
  hookFinishedStats;
  cbtSessionStats;
  logStats;
  launchBuildUsage;
  stopBuildUsage;
  static getInstance() {
    if (!_UsageStats.instance) {
      _UsageStats.instance = new _UsageStats();
    }
    return _UsageStats.instance;
  }
  constructor() {
    this.testStartedStats = new featureStats_default();
    this.testFinishedStats = new featureStats_default();
    this.hookStartedStats = new featureStats_default();
    this.hookFinishedStats = new featureStats_default();
    this.cbtSessionStats = new featureStats_default();
    this.logStats = new featureStats_default();
    this.launchBuildUsage = new featureUsage_default();
    this.stopBuildUsage = new featureUsage_default();
  }
  add(usageStats) {
    this.testStartedStats.add(usageStats.testStartedStats);
    this.testFinishedStats.add(usageStats.testFinishedStats);
    this.hookStartedStats.add(usageStats.hookStartedStats);
    this.hookFinishedStats.add(usageStats.hookFinishedStats);
    this.cbtSessionStats.add(usageStats.cbtSessionStats);
    this.logStats.add(usageStats.logStats);
  }
  getFormattedData(workersData) {
    this.addDataFromWorkers(workersData);
    const testOpsConfig = testOpsConfig_default.getInstance();
    const usage = {
      enabled: testOpsConfig.enabled,
      manuallySet: testOpsConfig.manuallySet,
      buildHashedId: testOpsConfig.buildHashedId
    };
    if (!usage.enabled) {
      return usage;
    }
    try {
      usage.events = this.getEventsData();
    } catch (e) {
      BStackLogger.debug("exception in getFormattedData: " + e);
    }
    return usage;
  }
  addDataFromWorkers(workersData) {
    workersData.map((workerData) => {
      try {
        const usageStatsForWorker = _UsageStats.fromJSON(workerData.usageStats);
        this.add(usageStatsForWorker);
      } catch (e) {
        BStackLogger.debug("Exception in adding workerData: " + e);
      }
    });
  }
  getEventsData() {
    return {
      buildEvents: {
        started: this.launchBuildUsage.toJSON(),
        finished: this.stopBuildUsage.toJSON()
      },
      testEvents: {
        started: this.testStartedStats.toJSON(),
        finished: this.testFinishedStats.toJSON({ omitGroups: true }),
        ...this.testFinishedStats.toJSON({ onlyGroups: true })
      },
      hookEvents: {
        started: this.hookStartedStats.toJSON(),
        finished: this.hookFinishedStats.toJSON({ omitGroups: true }),
        ...this.hookFinishedStats.toJSON({ onlyGroups: true })
      },
      logEvents: this.logStats.toJSON(),
      cbtSessionEvents: this.cbtSessionStats.toJSON()
    };
  }
  getDataToSave() {
    return {
      testEvents: {
        started: this.testStartedStats.toJSON(),
        finished: this.testFinishedStats.toJSON({ nestedGroups: true })
      },
      hookEvents: {
        started: this.hookStartedStats.toJSON(),
        finished: this.hookFinishedStats.toJSON({ nestedGroups: true })
      },
      logEvents: this.logStats.toJSON({ nestedGroups: true }),
      cbtSessionEvents: this.cbtSessionStats.toJSON()
    };
  }
  static fromJSON(data) {
    const usageStats = new _UsageStats();
    usageStats.testStartedStats = featureStats_default.fromJSON(data.testEvents.started);
    usageStats.testFinishedStats = featureStats_default.fromJSON(data.testEvents.finished);
    usageStats.hookStartedStats = featureStats_default.fromJSON(data.hookEvents.started);
    usageStats.hookFinishedStats = featureStats_default.fromJSON(data.hookEvents.finished);
    usageStats.logStats = featureStats_default.fromJSON(data.logEvents);
    usageStats.cbtSessionStats = featureStats_default.fromJSON(data.cbtSessionStats);
    return usageStats;
  }
};
var usageStats_default = UsageStats;

// src/scripts/accessibility-scripts.ts
import path2 from "node:path";
import fs2 from "node:fs";
import os from "node:os";
var AccessibilityScripts = class _AccessibilityScripts {
  static instance = null;
  performScan = null;
  getResults = null;
  getResultsSummary = null;
  saveTestResults = null;
  commandsToWrap = null;
  browserstackFolderPath = path2.join(os.homedir(), ".browserstack");
  commandsPath = path2.join(this.browserstackFolderPath, "commands.json");
  // don't allow to create instances from it other than through `checkAndGetInstance`
  constructor() {
  }
  static checkAndGetInstance() {
    if (!_AccessibilityScripts.instance) {
      _AccessibilityScripts.instance = new _AccessibilityScripts();
      _AccessibilityScripts.instance.readFromExistingFile();
    }
    return _AccessibilityScripts.instance;
  }
  readFromExistingFile() {
    try {
      if (fs2.existsSync(this.commandsPath)) {
        const data = fs2.readFileSync(this.commandsPath, "utf8");
        if (data) {
          this.update(JSON.parse(data));
        }
      }
    } catch (error) {
    }
  }
  update(data) {
    if (data.scripts) {
      this.performScan = data.scripts.scan;
      this.getResults = data.scripts.getResults;
      this.getResultsSummary = data.scripts.getResultsSummary;
      this.saveTestResults = data.scripts.saveResults;
    }
    if (data.commands && data.commands.length) {
      this.commandsToWrap = data.commands;
    }
  }
  store() {
    if (!fs2.existsSync(this.browserstackFolderPath)) {
      fs2.mkdirSync(this.browserstackFolderPath);
    }
    fs2.writeFileSync(this.commandsPath, JSON.stringify({
      commands: this.commandsToWrap,
      scripts: {
        scan: this.performScan,
        getResults: this.getResults,
        getResultsSummary: this.getResultsSummary,
        saveResults: this.saveTestResults
      }
    }));
  }
};
var accessibility_scripts_default = AccessibilityScripts.checkAndGetInstance();

// src/util.ts
var pGitconfig = promisify(gitconfig);
var DEFAULT_REQUEST_CONFIG = {
  headers: {
    "Content-Type": "application/json",
    "X-BSTACK-OBS": "true"
  }
};
var COLORS = {
  error: "red",
  warn: "yellow",
  info: "cyanBright",
  debug: "green",
  trace: "cyan",
  progress: "magenta"
};
function getBrowserDescription(cap) {
  cap = cap || {};
  if (cap["bstack:options"]) {
    cap = { ...cap, ...cap["bstack:options"] };
  }
  return BROWSER_DESCRIPTION.map((k) => cap[k]).filter(Boolean).join(" ");
}
function getBrowserCapabilities(browser, caps, browserName) {
  if (!browser.isMultiremote) {
    return { ...browser.capabilities, ...caps };
  }
  const multiCaps = caps;
  const globalCap = browserName && browser.getInstance(browserName) ? browser.getInstance(browserName).capabilities : {};
  const cap = browserName && multiCaps[browserName] ? multiCaps[browserName].capabilities : {};
  return { ...globalCap, ...cap };
}
function isBrowserstackCapability(cap) {
  return Boolean(
    cap && cap["bstack:options"] && // return false if the only cap in bstack:options is wdioService,
    // as that is added by the service and not present in user passed caps
    !(Object.keys(cap["bstack:options"]).length === 1 && cap["bstack:options"].wdioService)
  );
}
function getParentSuiteName(fullTitle, testSuiteTitle) {
  const fullTitleWords = fullTitle.split(" ");
  const testSuiteTitleWords = testSuiteTitle.split(" ");
  const shortestLength = Math.min(fullTitleWords.length, testSuiteTitleWords.length);
  let c = 0;
  let parentSuiteName = "";
  while (c < shortestLength && fullTitleWords[c] === testSuiteTitleWords[c]) {
    parentSuiteName += fullTitleWords[c++] + " ";
  }
  return parentSuiteName.trim();
}
function processError(error, fn, args) {
  BStackLogger.error(`Error in executing ${fn.name} with args ${args}: ${error}`);
  let argsString;
  try {
    argsString = JSON.stringify(args);
  } catch (e) {
    argsString = util.inspect(args, { depth: 2 });
  }
  CrashReporter.uploadCrashReport(`Error in executing ${fn.name} with args ${argsString} : ${error}`, error && error.stack);
}
function o11yErrorHandler(fn) {
  return function(...args) {
    try {
      let functionToHandle = fn;
      if (process.env[PERF_MEASUREMENT_ENV]) {
        functionToHandle = PerformanceTester.getPerformance().timerify(functionToHandle);
      }
      const result = functionToHandle(...args);
      if (result instanceof Promise) {
        return result.catch((error) => processError(error, fn, args));
      }
      return result;
    } catch (error) {
      processError(error, fn, args);
    }
  };
}
function errorHandler(fn) {
  return function(...args) {
    try {
      const functionToHandle = fn;
      const result = functionToHandle(...args);
      if (result instanceof Promise) {
        return result.catch((error) => BStackLogger.error(`Error in executing ${fn.name} with args ${args}: ${error}`));
      }
      return result;
    } catch (error) {
      BStackLogger.error(`Error in executing ${fn.name} with args ${args}: ${error}`);
    }
  };
}
async function nodeRequest(requestType, apiEndpoint, options, apiUrl, timeout = 12e4) {
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    const response = await fetch(`${apiUrl}/${apiEndpoint}`, {
      method: requestType,
      signal: controller.signal,
      ...options
    });
    clearTimeout(timeoutId);
    return await response.json();
  } catch (error) {
    const isLogUpload = apiEndpoint === UPLOAD_LOGS_ENDPOINT;
    if (error && error.response) {
      const errorMessageJson = error.response.body ? JSON.parse(error.response.body.toString()) : null;
      const errorMessage = errorMessageJson ? errorMessageJson.message : null;
      if (errorMessage) {
        isLogUpload ? BStackLogger.debug(`${errorMessage} - ${error.stack}`) : BStackLogger.error(`${errorMessage} - ${error.stack}`);
      } else {
        isLogUpload ? BStackLogger.debug(`${error.stack}`) : BStackLogger.error(`${error.stack}`);
      }
      if (isLogUpload) {
        return;
      }
      throw error;
    } else {
      if (isLogUpload) {
        BStackLogger.debug(`Failed to fire api request due to ${error} - ${error.stack}`);
        return;
      }
      BStackLogger.debug(`Failed to fire api request due to ${error} - ${error.stack}`);
      throw error;
    }
  }
}
function o11yClassErrorHandler(errorClass) {
  const prototype = errorClass.prototype;
  if (Object.getOwnPropertyNames(prototype).length < 2) {
    return errorClass;
  }
  Object.getOwnPropertyNames(prototype).forEach((methodName) => {
    const method = prototype[methodName];
    if (typeof method === "function" && methodName !== "constructor") {
      Object.defineProperty(prototype, methodName, {
        writable: true,
        value: function(...args) {
          try {
            const result = (process.env[PERF_MEASUREMENT_ENV] ? PerformanceTester.getPerformance().timerify(method) : method).call(this, ...args);
            if (result instanceof Promise) {
              return result.catch((error) => processError(error, method, args));
            }
            return result;
          } catch (err) {
            processError(err, method, args);
          }
        }
      });
    }
  });
  return errorClass;
}
var launchTestSession = o11yErrorHandler(async function launchTestSession2(options, config, bsConfig) {
  const launchBuildUsage = usageStats_default.getInstance().launchBuildUsage;
  launchBuildUsage.triggered();
  const data = {
    format: "json",
    project_name: getObservabilityProject(options, bsConfig.projectName),
    name: getObservabilityBuild(options, bsConfig.buildName),
    build_identifier: bsConfig.buildIdentifier,
    start_time: (/* @__PURE__ */ new Date()).toISOString(),
    tags: getObservabilityBuildTags(options, bsConfig.buildTag),
    host_info: {
      hostname: hostname(),
      platform: platform(),
      type: type(),
      version: version(),
      arch: arch()
    },
    ci_info: getCiInfo(),
    build_run_identifier: process.env.BROWSERSTACK_BUILD_RUN_IDENTIFIER,
    failed_tests_rerun: process.env[RERUN_ENV] || false,
    version_control: await getGitMetaData(),
    observability_version: {
      frameworkName: "WebdriverIO-" + config.framework,
      sdkVersion: bsConfig.bstackServiceVersion
    },
    config: {}
  };
  try {
    if (Object.keys(CrashReporter.userConfigForReporting).length === 0) {
      CrashReporter.userConfigForReporting = process.env.USER_CONFIG_FOR_REPORTING !== void 0 ? JSON.parse(process.env.USER_CONFIG_FOR_REPORTING) : {};
    }
  } catch (error) {
    return BStackLogger.error(`[Crash_Report_Upload] Failed to parse user config while sending build start event due to ${error}`);
  }
  data.config = CrashReporter.userConfigForReporting;
  try {
    const url3 = `${DATA_ENDPOINT}/api/v1/builds`;
    const encodedAuth = Buffer.from(`${getObservabilityUser(options, config)}:${getObservabilityKey(options, config)}`, "utf8").toString("base64");
    const headers = {
      ...DEFAULT_REQUEST_CONFIG.headers,
      Authorization: `Basic ${encodedAuth}`
    };
    const response = await fetch(url3, {
      method: "POST",
      headers,
      body: JSON.stringify(data)
    });
    const jsonResponse = await response.json();
    BStackLogger.debug(`[Start_Build] Success response: ${JSON.stringify(jsonResponse)}`);
    process.env[TESTOPS_BUILD_COMPLETED_ENV] = "true";
    if (jsonResponse.jwt) {
      process.env[TESTOPS_JWT_ENV] = jsonResponse.jwt;
      launchBuildUsage.success();
    }
    if (jsonResponse.build_hashed_id) {
      process.env[TESTOPS_BUILD_ID_ENV] = jsonResponse.build_hashed_id;
      testOpsConfig_default.getInstance().buildHashedId = jsonResponse.build_hashed_id;
    }
    if (jsonResponse.allow_screenshots) {
      process.env[TESTOPS_SCREENSHOT_ENV] = jsonResponse.allow_screenshots.toString();
    }
  } catch (error) {
    launchBuildUsage.failed(error);
    if (error && error.response) {
      const errorMessageJson = error.response.body ? JSON.parse(error.response.body.toString()) : null;
      const errorMessage = errorMessageJson ? errorMessageJson.message : null, errorType = errorMessageJson ? errorMessageJson.errorType : null;
      switch (errorType) {
        case "ERROR_INVALID_CREDENTIALS":
          BStackLogger.error(errorMessage);
          break;
        case "ERROR_ACCESS_DENIED":
          BStackLogger.info(errorMessage);
          break;
        case "ERROR_SDK_DEPRECATED":
          BStackLogger.error(errorMessage);
          break;
        default:
          BStackLogger.error(errorMessage);
      }
    } else {
      BStackLogger.error(`Data upload to BrowserStack Test Observability failed due to ${error}`);
    }
  }
});
var validateCapsWithA11y = (deviceName, platformMeta, chromeOptions) => {
  try {
    if (deviceName) {
      BStackLogger.warn("Accessibility Automation will run only on Desktop browsers.");
      return false;
    }
    if (platformMeta?.browser_name?.toLowerCase() !== "chrome") {
      BStackLogger.warn("Accessibility Automation will run only on Chrome browsers.");
      return false;
    }
    const browserVersion = platformMeta?.browser_version;
    if (!isUndefined(browserVersion) && !(browserVersion === "latest" || parseFloat(browserVersion + "") > 94)) {
      BStackLogger.warn("Accessibility Automation will run only on Chrome browser version greater than 94.");
      return false;
    }
    if (chromeOptions?.args?.includes("--headless")) {
      BStackLogger.warn("Accessibility Automation will not run on legacy headless mode. Switch to new headless mode or avoid using headless mode.");
      return false;
    }
    return true;
  } catch (error) {
    BStackLogger.debug(`Exception in checking capabilities compatibility with Accessibility. Error: ${error}`);
  }
  return false;
};
var shouldScanTestForAccessibility = (suiteTitle, testTitle, accessibilityOptions, world, isCucumber) => {
  try {
    const includeTags = Array.isArray(accessibilityOptions?.includeTagsInTestingScope) ? accessibilityOptions?.includeTagsInTestingScope : [];
    const excludeTags = Array.isArray(accessibilityOptions?.excludeTagsInTestingScope) ? accessibilityOptions?.excludeTagsInTestingScope : [];
    if (isCucumber) {
      const tagsList = [];
      world?.pickle?.tags.map((tag) => tagsList.push(tag.name));
      const excluded2 = excludeTags?.some((exclude) => tagsList.includes(exclude));
      const included2 = includeTags?.length === 0 || includeTags?.some((include) => tagsList.includes(include));
      return !excluded2 && included2;
    }
    const fullTestName = suiteTitle + " " + testTitle;
    const excluded = excludeTags?.some((exclude) => fullTestName.includes(exclude));
    const included = includeTags?.length === 0 || includeTags?.some((include) => fullTestName.includes(include));
    return !excluded && included;
  } catch (error) {
    BStackLogger.debug(`Error while validating test case for accessibility before scanning. Error : ${error}`);
  }
  return false;
};
var isAccessibilityAutomationSession = (accessibilityFlag) => {
  try {
    const hasA11yJwtToken = typeof process.env.BSTACK_A11Y_JWT === "string" && process.env.BSTACK_A11Y_JWT.length > 0 && process.env.BSTACK_A11Y_JWT !== "null" && process.env.BSTACK_A11Y_JWT !== "undefined";
    return accessibilityFlag && hasA11yJwtToken;
  } catch (error) {
    BStackLogger.debug(`Exception in verifying the Accessibility session with error : ${error}`);
  }
  return false;
};
var createAccessibilityTestRun = errorHandler(async function createAccessibilityTestRun2(options, config, bsConfig) {
  const userName = getBrowserStackUser(config);
  const accessKey = getBrowserStackKey(config);
  if (isUndefined(userName) || isUndefined(accessKey)) {
    BStackLogger.error("Exception while creating test run for BrowserStack Accessibility Automation: Missing BrowserStack credentials");
    return null;
  }
  const data = {
    "projectName": bsConfig.projectName,
    "buildName": bsConfig.buildName || path3.basename(path3.resolve(process.cwd())),
    "startTime": (/* @__PURE__ */ new Date()).toISOString(),
    "description": "",
    "source": {
      frameworkName: "WebdriverIO-" + config.framework,
      frameworkVersion: bsConfig.bstackServiceVersion,
      sdkVersion: bsConfig.bstackServiceVersion,
      language: "ECMAScript",
      testFramework: "webdriverIO",
      testFrameworkVersion: bsConfig.bstackServiceVersion
    },
    "settings": bsConfig.accessibilityOptions || {},
    "versionControl": await getGitMetaData(),
    "ciInfo": getCiInfo(),
    "hostInfo": {
      hostname: hostname(),
      platform: platform(),
      type: type(),
      version: version(),
      arch: arch()
    },
    "browserstackAutomation": true
  };
  const encodedAuth = Buffer.from(`${getBrowserStackUser(config)}:${getBrowserStackKey(config)}`, "utf8").toString("base64");
  const headers = {
    "Content-Type": "application/json; charset=utf-8",
    Authorization: `Basic ${encodedAuth}`
  };
  const requestOptions = {
    body: JSON.stringify(data),
    headers
  };
  try {
    const response = await nodeRequest(
      "POST",
      "v2/test_runs",
      requestOptions,
      ACCESSIBILITY_API_URL
    );
    BStackLogger.debug(`[Create Accessibility Test Run] Success response: ${JSON.stringify(response)}`);
    if (response.data.accessibilityToken) {
      process.env.BSTACK_A11Y_JWT = response.data.accessibilityToken;
    }
    if (response.data.id) {
      process.env.BS_A11Y_TEST_RUN_ID = response.data.id;
    }
    BStackLogger.debug(`BrowserStack Accessibility Automation Test Run ID: ${response.data.id}`);
    if (response.data) {
      accessibility_scripts_default.update(response.data);
      accessibility_scripts_default.store();
    }
    return response.data.scannerVersion;
  } catch (error) {
    if (error.response) {
      BStackLogger.error(
        `Exception while creating test run for BrowserStack Accessibility Automation: ${error.response.status} ${error.response.statusText} ${JSON.stringify(error.response.data)}`
      );
    } else {
      const errorMessage = error.message;
      if (errorMessage === "Invalid configuration passed.") {
        BStackLogger.error(
          `Exception while creating test run for BrowserStack Accessibility Automation: ${errorMessage || error.stack}`
        );
        for (const errorkey of error.errors) {
          BStackLogger.error(errorkey.message);
        }
      } else {
        BStackLogger.error(
          `Exception while creating test run for BrowserStack Accessibility Automation: ${errorMessage || error.stack}`
        );
      }
    }
    return null;
  }
});
var performA11yScan = async (browser, isBrowserStackSession, isAccessibility, commandName) => {
  if (!isBrowserStackSession) {
    BStackLogger.warn("Not a BrowserStack Automate session, cannot perform Accessibility scan.");
    return;
  }
  if (!isAccessibilityAutomationSession(isAccessibility)) {
    BStackLogger.warn("Not an Accessibility Automation session, cannot perform Accessibility scan.");
    return;
  }
  try {
    const results = await browser.executeAsync(accessibility_scripts_default.performScan, { "method": commandName || "" });
    BStackLogger.debug(util.format(results));
    return results;
  } catch (err) {
    BStackLogger.error("Accessibility Scan could not be performed : " + err);
    return;
  }
};
var getA11yResults = async (browser, isBrowserStackSession, isAccessibility) => {
  if (!isBrowserStackSession) {
    BStackLogger.warn("Not a BrowserStack Automate session, cannot retrieve Accessibility results.");
    return [];
  }
  if (!isAccessibilityAutomationSession(isAccessibility)) {
    BStackLogger.warn("Not an Accessibility Automation session, cannot retrieve Accessibility results.");
    return [];
  }
  try {
    BStackLogger.debug("Performing scan before getting results");
    await performA11yScan(browser, isBrowserStackSession, isAccessibility);
    const results = await browser.executeAsync(accessibility_scripts_default.getResults);
    return results;
  } catch {
    BStackLogger.error("No accessibility results were found.");
    return [];
  }
};
var getA11yResultsSummary = async (browser, isBrowserStackSession, isAccessibility) => {
  if (!isBrowserStackSession) {
    return {};
  }
  if (!isAccessibilityAutomationSession(isAccessibility)) {
    BStackLogger.warn("Not an Accessibility Automation session, cannot retrieve Accessibility results summary.");
    return {};
  }
  try {
    BStackLogger.debug("Performing scan before getting results summary");
    await performA11yScan(browser, isBrowserStackSession, isAccessibility);
    const summaryResults = await browser.executeAsync(accessibility_scripts_default.getResultsSummary);
    return summaryResults;
  } catch {
    BStackLogger.error("No accessibility summary was found.");
    return {};
  }
};
var stopAccessibilityTestRun = errorHandler(async function stopAccessibilityTestRun2() {
  const hasA11yJwtToken = typeof process.env.BSTACK_A11Y_JWT === "string" && process.env.BSTACK_A11Y_JWT.length > 0 && process.env.BSTACK_A11Y_JWT !== "null" && process.env.BSTACK_A11Y_JWT !== "undefined";
  if (!hasA11yJwtToken) {
    return {
      status: "error",
      message: "Build creation had failed."
    };
  }
  const data = {
    "endTime": (/* @__PURE__ */ new Date()).toISOString()
  };
  const requestOptions = { ...{
    json: data,
    headers: {
      "Authorization": `Bearer ${process.env.BSTACK_A11Y_JWT}`
    }
  } };
  try {
    const response = await nodeRequest(
      "PUT",
      "test_runs/stop",
      requestOptions,
      ACCESSIBILITY_API_URL
    );
    if (response.data && response.data.error) {
      throw new Error("Invalid request: " + response.data.error);
    } else if (response.error) {
      throw new Error("Invalid request: " + response.error);
    } else {
      BStackLogger.info(`BrowserStack Accessibility Automation Test Run marked as completed at ${(/* @__PURE__ */ new Date()).toISOString()}`);
      return { status: "success", message: "" };
    }
  } catch (error) {
    if (error.response && error.response.status && error.response.statusText && error.response.data) {
      BStackLogger.error(`Exception while marking completion of BrowserStack Accessibility Automation Test Run: ${error.response.status} ${error.response.statusText} ${JSON.stringify(error.response.data)}`);
    } else {
      BStackLogger.error(`Exception while marking completion of BrowserStack Accessibility Automation Test Run: ${error.message || util.format(error)}`);
    }
    return {
      status: "error",
      message: error.message || (error.response ? `${error.response.status}:${error.response.statusText}` : error)
    };
  }
});
var stopBuildUpstream = o11yErrorHandler(async function stopBuildUpstream2() {
  const stopBuildUsage = usageStats_default.getInstance().stopBuildUsage;
  stopBuildUsage.triggered();
  if (!process.env[TESTOPS_BUILD_COMPLETED_ENV]) {
    stopBuildUsage.failed("Build is not completed yet");
    return {
      status: "error",
      message: "Build is not completed yet"
    };
  }
  if (!process.env[TESTOPS_JWT_ENV]) {
    stopBuildUsage.failed("Token/buildID is undefined, build creation might have failed");
    BStackLogger.debug("[STOP_BUILD] Missing Authentication Token/ Build ID");
    return {
      status: "error",
      message: "Token/buildID is undefined, build creation might have failed"
    };
  }
  const data = {
    "stop_time": (/* @__PURE__ */ new Date()).toISOString()
  };
  try {
    const url3 = `${DATA_ENDPOINT}/api/v1/builds/${process.env[TESTOPS_BUILD_ID_ENV]}/stop`;
    const response = await fetch(url3, {
      method: "PUT",
      headers: {
        ...DEFAULT_REQUEST_CONFIG.headers,
        "Authorization": `Bearer ${process.env[TESTOPS_JWT_ENV]}`
      },
      body: JSON.stringify(data)
    });
    BStackLogger.debug(`[STOP_BUILD] Success response: ${await response.text()}`);
    stopBuildUsage.success();
    return {
      status: "success",
      message: ""
    };
  } catch (error) {
    stopBuildUsage.failed(error);
    BStackLogger.debug(`[STOP_BUILD] Failed. Error: ${error}`);
    return {
      status: "error",
      message: error.message
    };
  }
});
function getCiInfo() {
  const env = process.env;
  if (typeof env.JENKINS_URL === "string" && env.JENKINS_URL.length > 0 || typeof env.JENKINS_HOME === "string" && env.JENKINS_HOME.length > 0) {
    return {
      name: "Jenkins",
      build_url: env.BUILD_URL,
      job_name: env.JOB_NAME,
      build_number: env.BUILD_NUMBER
    };
  }
  if (isTrue(env.CI) && isTrue(env.CIRCLECI)) {
    return {
      name: "CircleCI",
      build_url: env.CIRCLE_BUILD_URL,
      job_name: env.CIRCLE_JOB,
      build_number: env.CIRCLE_BUILD_NUM
    };
  }
  if (isTrue(env.CI) && isTrue(env.TRAVIS)) {
    return {
      name: "Travis CI",
      build_url: env.TRAVIS_BUILD_WEB_URL,
      job_name: env.TRAVIS_JOB_NAME,
      build_number: env.TRAVIS_BUILD_NUMBER
    };
  }
  if (isTrue(env.CI) && env.CI_NAME === "codeship") {
    return {
      name: "Codeship",
      build_url: null,
      job_name: null,
      build_number: null
    };
  }
  if (env.BITBUCKET_BRANCH && env.BITBUCKET_COMMIT) {
    return {
      name: "Bitbucket",
      build_url: env.BITBUCKET_GIT_HTTP_ORIGIN,
      job_name: null,
      build_number: env.BITBUCKET_BUILD_NUMBER
    };
  }
  if (isTrue(env.CI) && isTrue(env.DRONE)) {
    return {
      name: "Drone",
      build_url: env.DRONE_BUILD_LINK,
      job_name: null,
      build_number: env.DRONE_BUILD_NUMBER
    };
  }
  if (isTrue(env.CI) && isTrue(env.SEMAPHORE)) {
    return {
      name: "Semaphore",
      build_url: env.SEMAPHORE_ORGANIZATION_URL,
      job_name: env.SEMAPHORE_JOB_NAME,
      build_number: env.SEMAPHORE_JOB_ID
    };
  }
  if (isTrue(env.CI) && isTrue(env.GITLAB_CI)) {
    return {
      name: "GitLab",
      build_url: env.CI_JOB_URL,
      job_name: env.CI_JOB_NAME,
      build_number: env.CI_JOB_ID
    };
  }
  if (isTrue(env.CI) && isTrue(env.BUILDKITE)) {
    return {
      name: "Buildkite",
      build_url: env.BUILDKITE_BUILD_URL,
      job_name: env.BUILDKITE_LABEL || env.BUILDKITE_PIPELINE_NAME,
      build_number: env.BUILDKITE_BUILD_NUMBER
    };
  }
  if (isTrue(env.TF_BUILD) && env.TF_BUILD_BUILDNUMBER) {
    return {
      name: "Visual Studio Team Services",
      build_url: `${env.SYSTEM_TEAMFOUNDATIONSERVERURI}${env.SYSTEM_TEAMPROJECTID}`,
      job_name: env.SYSTEM_DEFINITIONID,
      build_number: env.BUILD_BUILDID
    };
  }
  if (isTrue(env.APPVEYOR)) {
    return {
      name: "Appveyor",
      build_url: `${env.APPVEYOR_URL}/project/${env.APPVEYOR_ACCOUNT_NAME}/${env.APPVEYOR_PROJECT_SLUG}/builds/${env.APPVEYOR_BUILD_ID}`,
      job_name: env.APPVEYOR_JOB_NAME,
      build_number: env.APPVEYOR_BUILD_NUMBER
    };
  }
  if (env.AZURE_HTTP_USER_AGENT && env.TF_BUILD) {
    return {
      name: "Azure CI",
      build_url: `${env.SYSTEM_TEAMFOUNDATIONSERVERURI}${env.SYSTEM_TEAMPROJECT}/_build/results?buildId=${env.BUILD_BUILDID}`,
      job_name: env.BUILD_BUILDID,
      build_number: env.BUILD_BUILDID
    };
  }
  if (env.CODEBUILD_BUILD_ID || env.CODEBUILD_RESOLVED_SOURCE_VERSION || env.CODEBUILD_SOURCE_VERSION) {
    return {
      name: "AWS CodeBuild",
      build_url: env.CODEBUILD_PUBLIC_BUILD_URL,
      job_name: env.CODEBUILD_BUILD_ID,
      build_number: env.CODEBUILD_BUILD_ID
    };
  }
  if (env.bamboo_buildNumber) {
    return {
      name: "Bamboo",
      build_url: env.bamboo_buildResultsUrl,
      job_name: env.bamboo_shortJobName,
      build_number: env.bamboo_buildNumber
    };
  }
  if (env.WERCKER || env.WERCKER_MAIN_PIPELINE_STARTED) {
    return {
      name: "Wercker",
      build_url: env.WERCKER_BUILD_URL,
      job_name: env.WERCKER_MAIN_PIPELINE_STARTED ? "Main Pipeline" : null,
      build_number: env.WERCKER_GIT_COMMIT
    };
  }
  if (env.GCP_PROJECT || env.GCLOUD_PROJECT || env.GOOGLE_CLOUD_PROJECT) {
    return {
      name: "Google Cloud",
      build_url: null,
      job_name: env.PROJECT_ID,
      build_number: env.BUILD_ID
    };
  }
  if (env.SHIPPABLE) {
    return {
      name: "Shippable",
      build_url: env.SHIPPABLE_BUILD_URL,
      job_name: env.SHIPPABLE_JOB_ID ? `Job #${env.SHIPPABLE_JOB_ID}` : null,
      build_number: env.SHIPPABLE_BUILD_NUMBER
    };
  }
  if (isTrue(env.NETLIFY)) {
    return {
      name: "Netlify",
      build_url: env.DEPLOY_URL,
      job_name: env.SITE_NAME,
      build_number: env.BUILD_ID
    };
  }
  if (isTrue(env.GITHUB_ACTIONS)) {
    return {
      name: "GitHub Actions",
      build_url: `${env.GITHUB_SERVER_URL}/${env.GITHUB_REPOSITORY}/actions/runs/${env.GITHUB_RUN_ID}`,
      job_name: env.GITHUB_WORKFLOW,
      build_number: env.GITHUB_RUN_ID
    };
  }
  if (isTrue(env.CI) && env.VERCEL === "1") {
    return {
      name: "Vercel",
      build_url: `http://${env.VERCEL_URL}`,
      job_name: null,
      build_number: null
    };
  }
  if (env.TEAMCITY_VERSION) {
    return {
      name: "Teamcity",
      build_url: null,
      job_name: null,
      build_number: env.BUILD_NUMBER
    };
  }
  if (env.CONCOURSE || env.CONCOURSE_URL || env.CONCOURSE_USERNAME || env.CONCOURSE_TEAM) {
    return {
      name: "Concourse",
      build_url: null,
      job_name: env.BUILD_JOB_NAME || null,
      build_number: env.BUILD_ID || null
    };
  }
  if (env.GO_JOB_NAME) {
    return {
      name: "GoCD",
      build_url: null,
      job_name: env.GO_JOB_NAME,
      build_number: env.GO_PIPELINE_COUNTER
    };
  }
  if (env.CF_BUILD_ID) {
    return {
      name: "CodeFresh",
      build_url: env.CF_BUILD_URL,
      job_name: env.CF_PIPELINE_NAME,
      build_number: env.CF_BUILD_ID
    };
  }
  return null;
}
async function getGitMetaData() {
  const info = gitRepoInfo();
  if (!info.commonGitDir) {
    return;
  }
  const { remote } = await pGitconfig(info.commonGitDir);
  const remotes = remote ? Object.keys(remote).map((remoteName) => ({ name: remoteName, url: remote[remoteName].url })) : [];
  let gitMetaData = {
    name: "git",
    sha: info.sha,
    short_sha: info.abbreviatedSha,
    branch: info.branch,
    tag: info.tag,
    committer: info.committer,
    committer_date: info.committerDate,
    author: info.author,
    author_date: info.authorDate,
    commit_message: info.commitMessage,
    root: info.root,
    common_git_dir: info.commonGitDir,
    worktree_git_dir: info.worktreeGitDir,
    last_tag: info.lastTag,
    commits_since_last_tag: info.commitsSinceLastTag,
    remotes
  };
  gitMetaData = checkAndTruncateVCSInfo(gitMetaData);
  return gitMetaData;
}
function getUniqueIdentifier(test, framework) {
  if (framework === "jasmine") {
    return test.fullName;
  }
  let parentTitle = test.parent;
  if (typeof parentTitle === "object") {
    parentTitle = parentTitle.title;
  }
  return `${parentTitle} - ${test.title}`;
}
function getUniqueIdentifierForCucumber(world) {
  return world.pickle.uri + "_" + world.pickle.astNodeIds.join(",");
}
function getCloudProvider(browser) {
  if (browser.options && browser.options.hostname && browser.options.hostname.includes("browserstack")) {
    return "browserstack";
  }
  return "unknown_grid";
}
function isBrowserstackSession(browser) {
  return browser && getCloudProvider(browser).toLowerCase() === "browserstack";
}
function getScenarioExamples(world) {
  const scenario = world.pickle;
  if (scenario.astNodeIds && scenario.astNodeIds.length <= 1 || scenario.astNodeIds === void 0) {
    return;
  }
  const pickleId = scenario.astNodeIds[0];
  const examplesId = scenario.astNodeIds[1];
  const gherkinDocumentChildren = world.gherkinDocument.feature?.children;
  let examples = [];
  gherkinDocumentChildren?.forEach((child) => {
    if (child.rule) {
      child.rule.children.forEach((childLevel2) => {
        if (childLevel2.scenario && childLevel2.scenario.id === pickleId && childLevel2.scenario.examples) {
          const passedExamples = childLevel2.scenario.examples.flatMap((val) => val.tableBody).find((item) => item.id === examplesId)?.cells.map((val) => val.value);
          if (passedExamples) {
            examples = passedExamples;
          }
        }
      });
    } else if (child.scenario && child.scenario.id === pickleId && child.scenario.examples) {
      const passedExamples = child.scenario.examples.flatMap((val) => val.tableBody).find((item) => item.id === examplesId)?.cells.map((val) => val.value);
      if (passedExamples) {
        examples = passedExamples;
      }
    }
  });
  if (examples.length) {
    return examples;
  }
  return;
}
function removeAnsiColors(message) {
  if (!message) {
    return "";
  }
  return message.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, "");
}
function getLogTag(eventType) {
  if (eventType === "TestRunStarted" || eventType === "TestRunFinished") {
    return "Test_Upload";
  } else if (eventType === "HookRunStarted" || eventType === "HookRunFinished") {
    return "Hook_Upload";
  } else if (eventType === "ScreenshotCreated") {
    return "Screenshot_Upload";
  } else if (eventType === "LogCreated") {
    return "Log_Upload";
  }
  return "undefined";
}
function getHookType(hookName) {
  if (hookName.startsWith('"before each"')) {
    return "BEFORE_EACH";
  } else if (hookName.startsWith('"before all"')) {
    return "BEFORE_ALL";
  } else if (hookName.startsWith('"after each"')) {
    return "AFTER_EACH";
  } else if (hookName.startsWith('"after all"')) {
    return "AFTER_ALL";
  }
  return "unknown";
}
function isScreenshotCommand(args) {
  return args.endpoint && args.endpoint.includes("/screenshot");
}
function isBStackSession(config) {
  if (typeof config.user === "string" && typeof config.key === "string" && config.key.length === 20) {
    return true;
  }
  return false;
}
function isBrowserstackInfra(config, caps) {
  const isBrowserstack = (str) => {
    return str.includes("browserstack.com");
  };
  if (config.hostname && !isBrowserstack(config.hostname)) {
    return false;
  }
  if (caps && typeof caps === "object") {
    if (Array.isArray(caps)) {
      for (const capability of caps) {
        if (capability.hostname && !isBrowserstack(capability.hostname)) {
          return false;
        }
      }
    } else {
      for (const key in caps) {
        const capability = caps[key];
        if (capability.hostname && !isBrowserstack(capability.hostname)) {
          return false;
        }
      }
    }
  }
  if (!isBStackSession(config)) {
    return false;
  }
  return true;
}
function getBrowserStackUserAndKey(config, options) {
  const envOrServiceVariables = {
    user: getBrowserStackUser(options),
    key: getBrowserStackKey(options)
  };
  if (envOrServiceVariables.user && envOrServiceVariables.key) {
    return envOrServiceVariables;
  }
  const o11yVariables = {
    user: getObservabilityUser(options, config),
    key: getObservabilityKey(options, config)
  };
  return o11yVariables;
}
function shouldAddServiceVersion(config, testObservability, caps) {
  if (config.services && config.services.toString().includes("chromedriver") && testObservability !== false || !isBrowserstackInfra(config, caps)) {
    return false;
  }
  return true;
}
async function batchAndPostEvents(eventUrl, kind, data) {
  if (!process.env[TESTOPS_BUILD_COMPLETED_ENV]) {
    throw new Error("Build not completed yet");
  }
  const jwtToken = process.env[TESTOPS_JWT_ENV];
  if (!jwtToken) {
    throw new Error("Missing authentication Token");
  }
  try {
    const url3 = `${DATA_ENDPOINT}/${eventUrl}`;
    const response = await fetch(url3, {
      method: "POST",
      headers: {
        ...DEFAULT_REQUEST_CONFIG.headers,
        "Authorization": `Bearer ${jwtToken}`
      },
      body: JSON.stringify(data)
    });
    BStackLogger.debug(`[${kind}] Success response: ${JSON.stringify(await response.json())}`);
  } catch (error) {
    BStackLogger.debug(`[${kind}] EXCEPTION IN ${kind} REQUEST TO TEST OBSERVABILITY : ${error}`);
    throw new Error("Exception in request " + error);
  }
}
function getObservabilityUser(options, config) {
  if (process.env.BROWSERSTACK_USERNAME) {
    return process.env.BROWSERSTACK_USERNAME;
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.user) {
    return options.testObservabilityOptions.user;
  }
  return config.user;
}
function getObservabilityKey(options, config) {
  if (process.env.BROWSERSTACK_ACCESS_KEY) {
    return process.env.BROWSERSTACK_ACCESS_KEY;
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.key) {
    return options.testObservabilityOptions.key;
  }
  return config.key;
}
function getObservabilityProject(options, bstackProjectName) {
  if (process.env.TEST_OBSERVABILITY_PROJECT_NAME) {
    return process.env.TEST_OBSERVABILITY_PROJECT_NAME;
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.projectName) {
    return options.testObservabilityOptions.projectName;
  }
  return bstackProjectName;
}
function getObservabilityBuild(options, bstackBuildName) {
  if (process.env.TEST_OBSERVABILITY_BUILD_NAME) {
    return process.env.TEST_OBSERVABILITY_BUILD_NAME;
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.buildName) {
    return options.testObservabilityOptions.buildName;
  }
  return bstackBuildName || path3.basename(path3.resolve(process.cwd()));
}
function getObservabilityBuildTags(options, bstackBuildTag) {
  if (process.env.TEST_OBSERVABILITY_BUILD_TAG) {
    return process.env.TEST_OBSERVABILITY_BUILD_TAG.split(",");
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.buildTag) {
    return options.testObservabilityOptions.buildTag;
  }
  if (bstackBuildTag) {
    return [bstackBuildTag];
  }
  return [];
}
function getBrowserStackUser(config) {
  if (process.env.BROWSERSTACK_USERNAME) {
    return process.env.BROWSERSTACK_USERNAME;
  }
  return config.user;
}
function getBrowserStackKey(config) {
  if (process.env.BROWSERSTACK_ACCESS_KEY) {
    return process.env.BROWSERSTACK_ACCESS_KEY;
  }
  return config.key;
}
function isUndefined(value) {
  return value === void 0 || value === null;
}
function isTrue(value) {
  return (value + "").toLowerCase() === "true";
}
function frameworkSupportsHook(hook, framework) {
  if (framework === "mocha" && (hook === "before" || hook === "after" || hook === "beforeEach" || hook === "afterEach")) {
    return true;
  }
  if (framework === "cucumber") {
    return true;
  }
  return false;
}
var patchConsoleLogs = o11yErrorHandler(() => {
  const BSTestOpsPatcher = new logPatcher_default({});
  Object.keys(consoleHolder).forEach((method) => {
    const origMethod = console[method].bind(console);
    if (typeof console[method] === "function" && method !== "Console") {
      console[method] = (...args) => {
        origMethod(...args);
        BSTestOpsPatcher[method](...args);
      };
    }
  });
});
function getFailureObject(error) {
  const stack = error.stack;
  const message = typeof error === "string" ? error : error.message;
  const backtrace = stack ? removeAnsiColors(stack.toString()) : "";
  return {
    failure: [{ backtrace: [backtrace] }],
    failure_reason: removeAnsiColors(message.toString()),
    failure_type: message ? message.toString().match(/AssertionError/) ? "AssertionError" : "UnhandledError" : null
  };
}
var sleep = (ms = 100) => new Promise((resolve) => setTimeout(resolve, ms));
async function uploadLogs(user, key, clientBuildUuid) {
  if (!user || !key) {
    BStackLogger.debug("Uploading logs failed due to no credentials");
    return;
  }
  const fileStream = fs3.createReadStream(BStackLogger.logFilePath);
  const uploadAddress = UPLOAD_LOGS_ADDRESS;
  const zip = zlib.createGzip({ level: 1 });
  fileStream.pipe(zip);
  const formData = new FormData();
  formData.append("data", new FileStream(zip), "logs.gz");
  formData.append("clientBuildUuid", clientBuildUuid);
  const requestOptions = {
    body: formData,
    headers: {
      "Authorization": getBasicAuthHeader(user, key)
    }
  };
  const response = await nodeRequest(
    "POST",
    UPLOAD_LOGS_ENDPOINT,
    requestOptions,
    uploadAddress
  );
  return response;
}
var isObject = (object) => {
  return object !== null && typeof object === "object" && !Array.isArray(object);
};
var ObjectsAreEqual = (object1, object2) => {
  const objectKeys1 = Object.keys(object1);
  const objectKeys2 = Object.keys(object2);
  if (objectKeys1.length !== objectKeys2.length) {
    return false;
  }
  for (const key of objectKeys1) {
    const value1 = object1[key];
    const value2 = object2[key];
    const isBothAreObjects = isObject(value1) && isObject(value2);
    if (isBothAreObjects && !ObjectsAreEqual(value1, value2) || !isBothAreObjects && value1 !== value2) {
      return false;
    }
  }
  return true;
};
var getPlatformVersion = o11yErrorHandler(function getPlatformVersion2(caps) {
  if (!caps) {
    return void 0;
  }
  const bstackOptions = caps?.["bstack:options"];
  const keys = ["platformVersion", "platform_version", "osVersion", "os_version"];
  for (const key of keys) {
    if (bstackOptions && bstackOptions?.[key]) {
      return String(bstackOptions?.[key]);
    } else if (caps[key]) {
      return String(caps[key]);
    }
  }
  return void 0;
});
var getBasicAuthHeader = (username, password) => {
  const encodedAuth = Buffer.from(`${username}:${password}`, "utf8").toString("base64");
  return `Basic ${encodedAuth}`;
};
var isObjectEmpty = (objectName) => {
  return objectName && Object.keys(objectName).length === 0 && objectName.constructor === Object;
};
var getErrorString = (err) => {
  if (!err) {
    return void 0;
  }
  if (typeof err === "string") {
    return err;
  } else if (err instanceof Error) {
    return err.message;
  }
};
function truncateString(field, truncateSizeInBytes) {
  try {
    const bufferSizeInBytes = Buffer.from(GIT_META_DATA_TRUNCATED).length;
    const fieldBufferObj = Buffer.from(field);
    const lenOfFieldBufferObj = fieldBufferObj.length;
    const finalLen = Math.ceil(lenOfFieldBufferObj - truncateSizeInBytes - bufferSizeInBytes);
    if (finalLen > 0) {
      const truncatedString = fieldBufferObj.subarray(0, finalLen).toString() + GIT_META_DATA_TRUNCATED;
      return truncatedString;
    }
  } catch (error) {
    BStackLogger.debug(`Error while truncating field, nothing was truncated here: ${error}`);
  }
  return field;
}
function getSizeOfJsonObjectInBytes(jsonData) {
  try {
    const buffer = Buffer.from(JSON.stringify(jsonData));
    return buffer.length;
  } catch (error) {
    BStackLogger.debug(`Something went wrong while calculating size of JSON object: ${error}`);
  }
  return -1;
}
function checkAndTruncateVCSInfo(gitMetaData) {
  const gitMetaDataSizeInBytes = getSizeOfJsonObjectInBytes(gitMetaData);
  if (gitMetaDataSizeInBytes && gitMetaDataSizeInBytes > MAX_GIT_META_DATA_SIZE_IN_BYTES) {
    const truncateSize = gitMetaDataSizeInBytes - MAX_GIT_META_DATA_SIZE_IN_BYTES;
    const truncatedCommitMessage = truncateString(gitMetaData.commit_message, truncateSize);
    gitMetaData.commit_message = truncatedCommitMessage;
    BStackLogger.info(`The commit has been truncated. Size of commit after truncation is ${getSizeOfJsonObjectInBytes(gitMetaData) / 1024} KB`);
  }
  return gitMetaData;
}
var hasBrowserName = (cap) => {
  if (!cap || !cap.capabilities) {
    return false;
  }
  const browserStackCapabilities = cap.capabilities;
  return browserStackCapabilities.browserName !== void 0;
};
var isValidCapsForHealing = (caps) => {
  const capValues = Object.values(caps);
  return capValues.length > 0 && capValues.some(hasBrowserName);
};
function isTurboScale(options) {
  return Boolean(options?.turboScale);
}
function getObservabilityProduct(options, isAppAutomate) {
  return isAppAutomate ? "app-automate" : isTurboScale(options) ? "turboscale" : "automate";
}

// src/performance-tester.ts
var PerformanceTester = class {
  static _observer;
  static _csvWriter;
  static _events = [];
  static started = false;
  static startMonitoring(csvName = "performance-report.csv") {
    this._observer = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        this._events.push(entry);
      });
    });
    this._observer.observe({ buffered: true, entryTypes: ["function"] });
    this.started = true;
    this._csvWriter = createObjectCsvWriter({
      path: csvName,
      header: [
        { id: "name", title: "Function Name" },
        { id: "time", title: "Execution Time (ms)" }
      ]
    });
  }
  static getPerformance() {
    return performance;
  }
  static calculateTimes(methods) {
    const times = {};
    this._events.map((entry) => {
      if (!times[entry.name]) {
        times[entry.name] = 0;
      }
      times[entry.name] += entry.duration;
    });
    const timeTaken = methods.reduce((a, c) => {
      return times[c] + (a || 0);
    }, 0);
    BStackLogger.info(`Time for ${methods} is ${timeTaken}`);
    return timeTaken;
  }
  static async stopAndGenerate(filename = "performance-own.html") {
    if (!this.started) {
      return;
    }
    await sleep(2e3);
    this._observer.disconnect();
    this.started = false;
    this.generateCSV(this._events);
    const content = this.generateReport(this._events);
    const path14 = process.cwd() + "/" + filename;
    fs4.writeFile(path14, content, (err) => {
      if (err) {
        BStackLogger.error(`Error in writing html ${err}`);
        return;
      }
      BStackLogger.info(`Performance report is at ${path14}`);
    });
  }
  static generateReport(entries) {
    let html = "<!DOCTYPE html><html><head><title>Performance Report</title></head><body>";
    html += "<h1>Performance Report</h1>";
    html += "<table><thead><tr><th>Function Name</th><th>Duration (ms)</th></tr></thead><tbody>";
    entries.forEach((entry) => {
      html += `<tr><td>${entry.name}</td><td>${entry.duration}</td></tr>`;
    });
    html += "</tbody></table></body></html>";
    return html;
  }
  static generateCSV(entries) {
    const times = {};
    entries.map((entry) => {
      if (!times[entry.name]) {
        times[entry.name] = 0;
      }
      times[entry.name] += entry.duration;
      return {
        name: entry.name,
        time: entry.duration
      };
    });
    const dat = Object.entries(times).map(([key, value]) => {
      return {
        name: key,
        time: value
      };
    });
    this._csvWriter.writeRecords(dat).then(() => BStackLogger.info("Performance CSV report generated successfully")).catch((error) => console.error(error));
  }
};

// src/Percy/PercyLogger.ts
import path4 from "node:path";
import fs5 from "node:fs";
import chalk2 from "chalk";
import logger2 from "@wdio/logger";
var log2 = logger2("@wdio/browserstack-service");
var PercyLogger = class {
  static logFilePath = path4.join(process.cwd(), PERCY_LOGS_FILE);
  static logFolderPath = path4.join(process.cwd(), "logs");
  static logFileStream;
  static logToFile(logMessage, logLevel) {
    try {
      if (!this.logFileStream) {
        if (!fs5.existsSync(this.logFolderPath)) {
          fs5.mkdirSync(this.logFolderPath);
        }
        this.logFileStream = fs5.createWriteStream(this.logFilePath, { flags: "a" });
      }
      if (this.logFileStream && this.logFileStream.writable) {
        this.logFileStream.write(this.formatLog(logMessage, logLevel));
      }
    } catch (error) {
      log2.debug(`Failed to log to file. Error ${error}`);
    }
  }
  static formatLog(logMessage, level) {
    return `${chalk2.gray((/* @__PURE__ */ new Date()).toISOString())} ${chalk2[COLORS[level]](level.toUpperCase())} ${chalk2.whiteBright("@wdio/browserstack-service")} ${logMessage}
`;
  }
  static info(message) {
    this.logToFile(message, "info");
    log2.info(message);
  }
  static error(message) {
    this.logToFile(message, "error");
    log2.error(message);
  }
  static debug(message, param) {
    this.logToFile(message, "debug");
    if (param) {
      log2.debug(message, param);
    } else {
      log2.debug(message);
    }
  }
  static warn(message) {
    this.logToFile(message, "warn");
    log2.warn(message);
  }
  static trace(message) {
    this.logToFile(message, "trace");
    log2.trace(message);
  }
  static clearLogger() {
    if (this.logFileStream) {
      this.logFileStream.end();
    }
    this.logFileStream = null;
  }
  static clearLogFile() {
    if (fs5.existsSync(this.logFilePath)) {
      fs5.truncateSync(this.logFilePath);
    }
  }
};

// src/Percy/Percy.ts
import fs7 from "node:fs";
import path6 from "node:path";
import os3 from "node:os";
import { spawn as spawn2 } from "node:child_process";

// src/Percy/PercyBinary.ts
import yauzl from "yauzl";
import fs6 from "node:fs";
import fsp from "node:fs/promises";
import { pipeline } from "node:stream/promises";
import path5 from "node:path";
import os2 from "node:os";
import { spawn } from "node:child_process";
var PercyBinary = class {
  #hostOS = process.platform;
  #httpPath = null;
  #binaryName = "percy";
  #orderedPaths = [
    path5.join(os2.homedir(), ".browserstack"),
    process.cwd(),
    os2.tmpdir()
  ];
  constructor() {
    const base = "https://github.com/percy/cli/releases/latest/download";
    if (this.#hostOS.match(/darwin|mac os/i)) {
      this.#httpPath = base + "/percy-osx.zip";
    } else if (this.#hostOS.match(/mswin|msys|mingw|cygwin|bccwin|wince|emc|win32/i)) {
      this.#httpPath = base + "/percy-win.zip";
      this.#binaryName = "percy.exe";
    } else {
      this.#httpPath = base + "/percy-linux.zip";
    }
  }
  async #makePath(path14) {
    if (await this.#checkPath(path14)) {
      return true;
    }
    return fsp.mkdir(path14).then(() => true).catch(() => false);
  }
  async #checkPath(path14) {
    try {
      const hasDir = await fsp.access(path14).then(() => true, () => false);
      if (hasDir) {
        return true;
      }
    } catch (err) {
      return false;
    }
  }
  async #getAvailableDirs() {
    for (let i = 0; i < this.#orderedPaths.length; i++) {
      const path14 = this.#orderedPaths[i];
      if (await this.#makePath(path14)) {
        return path14;
      }
    }
    throw new Error("Error trying to download percy binary");
  }
  async getBinaryPath() {
    const destParentDir = await this.#getAvailableDirs();
    const binaryPath = path5.join(destParentDir, this.#binaryName);
    if (await this.#checkPath(binaryPath)) {
      return binaryPath;
    }
    const downloadedBinaryPath = await this.download(destParentDir);
    const isValid = await this.validateBinary(downloadedBinaryPath);
    if (!isValid) {
      PercyLogger.error("Corrupt percy binary, retrying");
      return await this.download(destParentDir);
    }
    return downloadedBinaryPath;
  }
  async validateBinary(binaryPath) {
    const versionRegex = /^.*@percy\/cli \d.\d+.\d+/;
    return new Promise((resolve, reject) => {
      const proc = spawn(binaryPath, ["--version"]);
      proc.stdout.on("data", (data) => {
        if (versionRegex.test(data)) {
          resolve(true);
        }
      });
      proc.on("close", () => {
        resolve(false);
      });
    });
  }
  async download(destParentDir) {
    if (!await this.#checkPath(destParentDir)) {
      await fsp.mkdir(destParentDir);
    }
    const binaryName = this.#binaryName;
    const zipFilePath = path5.join(destParentDir, binaryName + ".zip");
    const binaryPath = path5.join(destParentDir, binaryName);
    const downloadedFileStream = fs6.createWriteStream(zipFilePath);
    const response = await fetch(this.#httpPath);
    await pipeline(response.body, downloadedFileStream);
    return new Promise((resolve, reject) => {
      yauzl.open(zipFilePath, { lazyEntries: true }, function(err, zipfile) {
        if (err) {
          return reject(err);
        }
        zipfile.readEntry();
        zipfile.on("entry", (entry) => {
          if (/\/$/.test(entry.fileName)) {
            zipfile.readEntry();
          } else {
            const writeStream = fs6.createWriteStream(
              path5.join(destParentDir, entry.fileName)
            );
            zipfile.openReadStream(entry, function(zipErr, readStream) {
              if (zipErr) {
                reject(err);
              }
              readStream.on("end", function() {
                writeStream.close();
                zipfile.readEntry();
              });
              readStream.pipe(writeStream);
            });
            if (entry.fileName === binaryName) {
              zipfile.close();
            }
          }
        });
        zipfile.on("error", (zipErr) => {
          reject(zipErr);
        });
        zipfile.once("end", () => {
          fs6.chmod(binaryPath, "0755", function(zipErr) {
            if (zipErr) {
              reject(zipErr);
            }
            resolve(binaryPath);
          });
          zipfile.close();
        });
      });
    });
  }
};
var PercyBinary_default = PercyBinary;

// src/Percy/Percy.ts
var logDir = "logs";
var Percy = class {
  #logfile = path6.join(logDir, "percy.log");
  #address = process.env.PERCY_SERVER_ADDRESS || "http://127.0.0.1:5338";
  #binaryPath = null;
  #options;
  #config;
  #proc = null;
  #isApp;
  #projectName = void 0;
  isProcessRunning = false;
  percyCaptureMode;
  buildId = null;
  percyAutoEnabled = false;
  percy;
  constructor(options, config, bsConfig) {
    this.#options = options;
    this.#config = config;
    this.#isApp = Boolean(options.app);
    this.#projectName = bsConfig.projectName;
    this.percyCaptureMode = options.percyCaptureMode;
    this.percy = options.percy ?? false;
  }
  async #getBinaryPath() {
    if (!this.#binaryPath) {
      const pb = new PercyBinary_default();
      this.#binaryPath = await pb.getBinaryPath();
    }
    return this.#binaryPath;
  }
  async healthcheck() {
    try {
      const resp = await nodeRequest("GET", "percy/healthcheck", null, this.#address);
      if (resp) {
        this.buildId = resp.build.id;
        return true;
      }
    } catch (err) {
      return false;
    }
  }
  async start() {
    const binaryPath = await this.#getBinaryPath();
    const logStream = fs7.createWriteStream(this.#logfile, { flags: "a" });
    const token = await this.fetchPercyToken();
    const configPath = await this.createPercyConfig();
    if (!token) {
      return false;
    }
    const commandArgs = [`${this.#isApp ? "app:exec" : "exec"}:start`];
    if (configPath) {
      commandArgs.push("-c", configPath);
    }
    this.#proc = spawn2(
      binaryPath,
      commandArgs,
      { env: { ...process.env, PERCY_TOKEN: token } }
    );
    this.#proc.stdout.pipe(logStream);
    this.#proc.stderr.pipe(logStream);
    this.isProcessRunning = true;
    const that = this;
    this.#proc.on("close", function() {
      that.isProcessRunning = false;
    });
    do {
      const healthcheck = await this.healthcheck();
      if (healthcheck) {
        PercyLogger.debug("Percy healthcheck successful");
        return true;
      }
      await sleep(1e3);
    } while (this.isProcessRunning);
    return false;
  }
  async stop() {
    const binaryPath = await this.#getBinaryPath();
    return new Promise((resolve) => {
      const proc = spawn2(binaryPath, ["exec:stop"]);
      proc.on("close", (code) => {
        this.isProcessRunning = false;
        resolve(code);
      });
    });
  }
  isRunning() {
    return this.isProcessRunning;
  }
  async fetchPercyToken() {
    const projectName = this.#projectName;
    try {
      const type2 = this.#isApp ? "app" : "automate";
      const params = new URLSearchParams();
      if (projectName) {
        params.set("name", projectName);
      }
      if (type2) {
        params.set("type", type2);
      }
      if (this.#options.percyCaptureMode) {
        params.set("percy_capture_mode", this.#options.percyCaptureMode);
      }
      params.set("percy", String(this.#options.percy));
      const query = `api/app_percy/get_project_token?${params.toString()}`;
      const response = await nodeRequest(
        "GET",
        query,
        {
          username: getBrowserStackUser(this.#config),
          password: getBrowserStackKey(this.#config)
        },
        "https://api.browserstack.com"
      );
      PercyLogger.debug("Percy fetch token success : " + response.token);
      if (!this.#options.percy && response.success) {
        this.percyAutoEnabled = response.success;
      }
      this.percyCaptureMode = response.percy_capture_mode;
      this.percy = response.success;
    } catch (err) {
      PercyLogger.error(`Percy unable to fetch project token: ${err}`);
      return null;
    }
  }
  async createPercyConfig() {
    if (!this.#options.percyOptions) {
      return null;
    }
    const configPath = path6.join(os3.tmpdir(), "percy.json");
    const percyOptions = this.#options.percyOptions;
    if (!percyOptions.version) {
      percyOptions.version = "2";
    }
    return new Promise((resolve) => {
      fs7.writeFile(
        configPath,
        JSON.stringify(
          percyOptions
        ),
        (err) => {
          if (err) {
            PercyLogger.error(`Error creating percy config: ${err}`);
            resolve(null);
          }
          PercyLogger.debug("Percy config created at " + configPath);
          resolve(configPath);
        }
      );
    });
  }
};
var Percy_default = Percy;

// src/Percy/PercyHelper.ts
var startPercy = async (options, config, bsConfig) => {
  PercyLogger.debug("Starting percy");
  const percy = new Percy_default(options, config, bsConfig);
  const response = await percy.start();
  if (response) {
    return percy;
  }
  return {};
};
var stopPercy = async (percy) => {
  PercyLogger.debug("Stopping percy");
  return percy.stop();
};
var getBestPlatformForPercySnapshot = (capabilities) => {
  try {
    const percyBrowserPreference = { "chrome": 0, "firefox": 1, "edge": 2, "safari": 3 };
    let bestPlatformCaps = null;
    let bestBrowser = null;
    if (Array.isArray(capabilities)) {
      capabilities.flatMap((c) => {
        if ("alwaysMatch" in c) {
          return c.alwaysMatch;
        }
        if (Object.values(c).length > 0 && Object.values(c).every((c2) => typeof c2 === "object" && c2.capabilities)) {
          return Object.values(c).map((o) => o.capabilities);
        }
        return c;
      }).forEach((capability) => {
        let currBrowserName = capability.browserName;
        if (capability["bstack:options"]) {
          currBrowserName = capability["bstack:options"].browserName || currBrowserName;
        }
        if (!bestBrowser || !bestPlatformCaps || (bestPlatformCaps.deviceName || bestPlatformCaps["bstack:options"]?.deviceName)) {
          bestBrowser = currBrowserName;
          bestPlatformCaps = capability;
        } else if (currBrowserName && percyBrowserPreference[currBrowserName.toLowerCase()] < percyBrowserPreference[bestBrowser.toLowerCase()]) {
          bestBrowser = currBrowserName;
          bestPlatformCaps = capability;
        }
      });
      return bestPlatformCaps;
    } else if (typeof capabilities === "object") {
      Object.entries(capabilities).forEach(([, caps]) => {
        let currBrowserName = caps.capabilities.browserName;
        if (caps.capabilities["bstack:options"]) {
          currBrowserName = caps.capabilities["bstack:options"]?.browserName || currBrowserName;
        }
        if (!bestBrowser || !bestPlatformCaps || (bestPlatformCaps.deviceName || bestPlatformCaps["bstack:options"]?.deviceName)) {
          bestBrowser = currBrowserName;
          bestPlatformCaps = caps.capabilities;
        } else if (currBrowserName && percyBrowserPreference[currBrowserName.toLowerCase()] < percyBrowserPreference[bestBrowser.toLowerCase()]) {
          bestBrowser = currBrowserName;
          bestPlatformCaps = caps.capabilities;
        }
      });
      return bestPlatformCaps;
    }
  } catch (err) {
    PercyLogger.error(`Error while trying to determine best platform for Percy snapshot ${err}`);
    return null;
  }
};

// src/config.ts
var BrowserStackConfig = class _BrowserStackConfig {
  static getInstance(options, config) {
    if (!this._instance && options && config) {
      this._instance = new _BrowserStackConfig(options, config);
    }
    return this._instance;
  }
  userName;
  accessKey;
  framework;
  buildName;
  buildIdentifier;
  testObservability;
  percy;
  percyCaptureMode;
  accessibility;
  app;
  static _instance;
  appAutomate;
  automate;
  funnelDataSent = false;
  percyBuildId;
  isPercyAutoEnabled = false;
  constructor(options, config) {
    this.framework = config.framework;
    this.userName = config.user;
    this.accessKey = config.key;
    this.testObservability = new testOpsConfig_default(options.testObservability !== false, !isUndefined(options.testObservability));
    this.percy = options.percy || false;
    this.accessibility = options.accessibility || false;
    this.app = options.app;
    this.appAutomate = !isUndefined(options.app);
    this.automate = !this.appAutomate;
    this.buildIdentifier = options.buildIdentifier;
  }
  sentFunnelData() {
    this.funnelDataSent = true;
  }
};
var config_default = BrowserStackConfig;

// src/exitHandler.ts
import { spawn as spawn3 } from "node:child_process";
import path9 from "node:path";

// src/instrumentation/funnelInstrumentation.ts
import os4 from "node:os";
import util2 from "node:util";
import path8 from "node:path";
import fs9 from "node:fs";

// src/data-store.ts
import path7 from "node:path";
import fs8 from "node:fs";
var workersDataDirPath = path7.join(process.cwd(), "logs", "worker_data");
function getDataFromWorkers() {
  const workersData = [];
  if (!fs8.existsSync(workersDataDirPath)) {
    return workersData;
  }
  const files = fs8.readdirSync(workersDataDirPath);
  files.forEach((file) => {
    BStackLogger.debug("Reading worker file " + file);
    const filePath = path7.join(workersDataDirPath, file);
    const fileContent = fs8.readFileSync(filePath, "utf8");
    const workerData = JSON.parse(fileContent);
    workersData.push(workerData);
  });
  removeWorkersDataDir();
  return workersData;
}
function saveWorkerData(data) {
  const filePath = path7.join(workersDataDirPath, "worker-data-" + process.pid + ".json");
  try {
    createWorkersDataDir();
    fs8.writeFileSync(filePath, JSON.stringify(data));
  } catch (e) {
    BStackLogger.debug("Exception in saving worker data: " + e);
  }
}
function removeWorkersDataDir() {
  fs8.rmSync(workersDataDirPath, { recursive: true, force: true });
  return true;
}
function createWorkersDataDir() {
  if (!fs8.existsSync(workersDataDirPath)) {
    fs8.mkdirSync(workersDataDirPath, { recursive: true });
  }
  return true;
}

// src/fetchWrapper.ts
var ResponseError = class extends Error {
  response;
  constructor(message, res) {
    super(message);
    this.response = res;
  }
};
async function fetchWrap(input, init) {
  const res = await fetch(input, init);
  if (!res.ok) {
    throw new ResponseError(`Error response from server ${res.status}:  ${await res.text()}`, res);
  }
  return res;
}

// src/instrumentation/funnelInstrumentation.ts
async function fireFunnelTestEvent(eventType, config) {
  if (!config.userName || !config.accessKey) {
    BStackLogger.debug("username/accesskey not passed");
    return;
  }
  try {
    const data = buildEventData(eventType, config);
    await fireFunnelRequest(data);
    BStackLogger.debug("Funnel event success");
    config.sentFunnelData();
  } catch (error) {
    BStackLogger.debug("Exception in sending funnel data: " + error);
  }
}
async function sendStart(config) {
  await fireFunnelTestEvent("SDKTestAttempted", config);
}
async function sendFinish(config) {
  await fireFunnelTestEvent("SDKTestSuccessful", config);
}
function saveFunnelData(eventType, config) {
  const data = buildEventData(eventType, config);
  BStackLogger.ensureLogsFolder();
  const filePath = path8.join(BStackLogger.logFolderPath, "funnelData.json");
  fs9.writeFileSync(filePath, JSON.stringify(data));
  return filePath;
}
async function fireFunnelRequest(data) {
  BStackLogger.debug("Sending SDK event with data " + util2.inspect(data, { depth: 6 }));
  const encodedAuth = Buffer.from(`${data.userName}:${data.accessKey}`, "utf8").toString("base64");
  const response = await fetchWrap(FUNNEL_INSTRUMENTATION_URL, {
    method: "POST",
    headers: {
      "content-type": "application/json",
      Authorization: `Basic ${encodedAuth}`
    },
    body: JSON.stringify(data)
  });
  BStackLogger.debug("Funnel Event Response: " + JSON.stringify(await response.text()));
}
function getProductList(config) {
  const products = [];
  if (config.testObservability.enabled) {
    products.push("observability");
  }
  if (config.accessibility) {
    products.push("accessibility");
  }
  if (config.percy) {
    products.push("percy");
  }
  if (config.automate) {
    products.push("automate");
  }
  if (config.appAutomate) {
    products.push("app-automate");
  }
  return products;
}
function getProductMap(config) {
  return {
    "observability": config.testObservability.enabled,
    "accessibility": config.accessibility,
    "percy": config.percy,
    "automate": config.automate,
    "app_automate": config.appAutomate
  };
}
function buildEventData(eventType, config) {
  const eventProperties = {
    // Framework Details
    language_framework: getLanguageFramework(config.framework),
    referrer: getReferrer(config.framework),
    language: "WebdriverIO",
    languageVersion: process.version,
    // Build Details
    buildName: config.buildName || "undefined",
    buildIdentifier: String(config.buildIdentifier),
    // Host details
    os: os4.type() || "unknown",
    hostname: os4.hostname() || "unknown",
    // Product Details
    productMap: getProductMap(config),
    product: getProductList(config)
  };
  if (eventType === "SDKTestSuccessful") {
    const workerData = getDataFromWorkers();
    eventProperties.productUsage = getProductUsage(workerData);
  }
  return {
    userName: config.userName,
    accessKey: config.accessKey,
    event_type: eventType,
    detectedFramework: "WebdriverIO-" + config.framework,
    event_properties: eventProperties
  };
}
function getProductUsage(workersData) {
  return {
    testObservability: usageStats_default.getInstance().getFormattedData(workersData)
  };
}
function getLanguageFramework(framework) {
  return "WebdriverIO_" + framework;
}
function getReferrer(framework) {
  const fullName = framework ? "WebdriverIO-" + framework : "WebdriverIO";
  return `${fullName}/${BSTACK_SERVICE_VERSION}`;
}
var sendEvent = {
  tcgDown: (config) => fireFunnelTestEvent("SDKTestTcgDownResponse", config),
  invalidTcgAuth: (config) => fireFunnelTestEvent("SDKTestInvalidTcgAuthResponseWithUserImpact", config),
  tcgAuthFailure: (config) => fireFunnelTestEvent("SDKTestTcgAuthFailure", config),
  tcgtInitSuccessful: (config) => fireFunnelTestEvent("SDKTestTcgtInitSuccessful", config),
  initFailed: (config) => fireFunnelTestEvent("SDKTestInitFailedResponse", config),
  tcgProxyFailure: (config) => fireFunnelTestEvent("SDKTestTcgProxyFailure", config)
};
function isProxyError(authResult) {
  return authResult.status === 502;
}
function handleProxyError(config, isSelfHealEnabled) {
  sendEvent.tcgProxyFailure(config);
  if (isSelfHealEnabled) {
    BStackLogger.warn("Proxy Error. Disabling Healing for this session.");
  }
}
function handleUpgradeRequired(isSelfHealEnabled) {
  if (isSelfHealEnabled) {
    BStackLogger.warn("Please upgrade Browserstack Service to the latest version to use the self-healing feature.");
  }
}
function handleAuthenticationFailure(status, config, isSelfHealEnabled) {
  if (status >= 500) {
    if (isSelfHealEnabled) {
      BStackLogger.warn("Something went wrong. Disabling healing for this session. Please try again later.");
    }
    sendEvent.tcgDown(config);
  } else {
    if (isSelfHealEnabled) {
      BStackLogger.warn("Authentication Failed. Disabling Healing for this session.");
    }
    sendEvent.tcgAuthFailure(config);
  }
}
function handleAuthenticationSuccess(isHealingEnabledForUser, userId, config, isSelfHealEnabled) {
  if (!isHealingEnabledForUser && isSelfHealEnabled) {
    BStackLogger.warn("Healing is not enabled for your group, please contact the admin");
  } else if (userId && isHealingEnabledForUser) {
    sendEvent.tcgtInitSuccessful(config);
  }
}
function handleInitializationFailure(status, config, isSelfHealEnabled) {
  if (status >= 400) {
    sendEvent.initFailed(config);
  } else if (!status && isSelfHealEnabled) {
    sendEvent.invalidTcgAuth(config);
  }
  if (isSelfHealEnabled) {
    BStackLogger.warn("Authentication Failed. Healing will be disabled for this session.");
  }
}
function handleHealingInstrumentation(authResult, config, isSelfHealEnabled) {
  try {
    if (isProxyError(authResult)) {
      handleProxyError(config, isSelfHealEnabled);
      return;
    }
    const { message, isAuthenticated, status, userId, groupId, isHealingEnabled: isHealingEnabledForUser } = authResult;
    if (message === "Upgrade required") {
      handleUpgradeRequired(isSelfHealEnabled);
      return;
    }
    if (!isAuthenticated) {
      handleAuthenticationFailure(status, config, isSelfHealEnabled);
      return;
    }
    if (isAuthenticated && userId && groupId) {
      handleAuthenticationSuccess(isHealingEnabledForUser, userId, config, isSelfHealEnabled);
      return;
    }
    if (status >= 400 || !status) {
      handleInitializationFailure(status, config, isSelfHealEnabled);
      return;
    }
  } catch (err) {
    BStackLogger.debug("Error in handling healing instrumentation: " + err);
  }
}

// src/exitHandler.ts
import { fileURLToPath } from "node:url";
var __filename = fileURLToPath(import.meta.url);
var __dirname = path9.dirname(__filename);
function setupExitHandlers() {
  process.on("exit", (code) => {
    const args = shouldCallCleanup(config_default.getInstance());
    if (Array.isArray(args) && args.length) {
      const childProcess = spawn3("node", [`${path9.join(__dirname, "cleanup.js")}`, ...args], { detached: true, stdio: "inherit", env: { ...process.env } });
      childProcess.unref();
      process.exit(code);
    }
  });
}
function shouldCallCleanup(config) {
  const args = [];
  if (!!process.env[TESTOPS_JWT_ENV] && !config.testObservability.buildStopped) {
    args.push("--observability");
  }
  if (config.userName && config.accessKey && !config.funnelDataSent) {
    const savedFilePath = saveFunnelData("SDKTestSuccessful", config);
    args.push("--funnelData", savedFilePath);
  }
  return args;
}

// src/ai-handler.ts
import path10 from "node:path";
import fs10 from "node:fs";
import url from "node:url";
import aiSDK from "@browserstack/ai-sdk-node";
var AiHandler = class {
  authResult;
  wdioBstackVersion;
  constructor() {
    this.authResult = JSON.parse(process.env[BSTACK_TCG_AUTH_RESULT] || "{}");
    this.wdioBstackVersion = BSTACK_SERVICE_VERSION;
  }
  async authenticateUser(user, key) {
    return await aiSDK.BrowserstackHealing.init(key, user, TCG_URL, this.wdioBstackVersion);
  }
  updateCaps(authResult, options, caps) {
    const installExtCondition = authResult.isAuthenticated === true && (authResult.defaultLogDataEnabled === true || options.selfHeal === true);
    if (installExtCondition) {
      if (Array.isArray(caps)) {
        const newCaps = aiSDK.BrowserstackHealing.initializeCapabilities(caps[0]);
        caps[0] = newCaps;
      } else if (typeof caps === "object") {
        caps = aiSDK.BrowserstackHealing.initializeCapabilities(caps);
      }
    } else if (options.selfHeal === true) {
      const healingWarnMessage = authResult.message;
      BStackLogger.warn(`Healing Auth failed. Disabling healing for this session. Reason: ${healingWarnMessage}`);
    }
    return caps;
  }
  async setToken(sessionId, sessionToken) {
    await aiSDK.BrowserstackHealing.setToken(sessionId, sessionToken, TCG_URL);
  }
  async installFirefoxExtension(browser) {
    const __dirname2 = url.fileURLToPath(new URL(".", import.meta.url));
    const extensionPath = path10.resolve(__dirname2, aiSDK.BrowserstackHealing.getFirefoxAddonPath());
    const extFile = fs10.readFileSync(extensionPath);
    await browser.installAddOn(extFile.toString("base64"), true);
  }
  async handleHealing(orginalFunc, using, value, browser, options) {
    const sessionId = browser.sessionId;
    const escapeString = (str) => str.replace(/'/g, "\\'").replace(/"/g, '\\"');
    const tcgDetails = escapeString(JSON.stringify({
      region: TCG_INFO.tcgRegion,
      tcgUrls: {
        [TCG_INFO.tcgRegion]: {
          endpoint: TCG_INFO.tcgUrl.split("://")[1]
        }
      }
    }));
    const locatorType = escapeString(using);
    const locatorValue = escapeString(value);
    this.authResult = this.authResult;
    try {
      const result = await orginalFunc(using, value);
      if (!result.error) {
        const script = await aiSDK.BrowserstackHealing.logData(locatorType, locatorValue, void 0, void 0, this.authResult.groupId, sessionId, void 0, tcgDetails);
        if (script) {
          await browser.execute(script);
        }
        return result;
      }
      if (options.selfHeal === true && this.authResult.isHealingEnabled) {
        BStackLogger.info("findElement failed, trying to heal");
        const script = await aiSDK.BrowserstackHealing.healFailure(locatorType, locatorValue, void 0, void 0, this.authResult.userId, this.authResult.groupId, sessionId, void 0, void 0, this.authResult.isGroupAIEnabled, tcgDetails);
        if (script) {
          await browser.execute(script);
          const tcgData = await aiSDK.BrowserstackHealing.pollResult(TCG_URL, sessionId, this.authResult.sessionToken);
          if (tcgData && tcgData.selector && tcgData.value) {
            const healedResult = await orginalFunc(tcgData.selector, tcgData.value);
            BStackLogger.info("Healing worked, element found: " + tcgData.selector + ": " + tcgData.value);
            return healedResult.error ? result : healedResult;
          }
        }
      }
    } catch (err) {
      if (options.selfHeal === true) {
        BStackLogger.warn("Something went wrong while healing. Disabling healing for this command");
      } else {
        BStackLogger.warn("Error in findElement: " + err + "using: " + using + "value: " + value);
      }
    }
    return await orginalFunc(using, value);
  }
  addMultiRemoteCaps(authResult, config, browserStackConfig, options, caps, browser) {
    if (caps[browser].capabilities && !isBrowserstackInfra(caps[browser]) && SUPPORTED_BROWSERS_FOR_AI.includes(caps[browser]?.capabilities?.browserName?.toLowerCase())) {
      const innerConfig = getBrowserStackUserAndKey(config, options);
      if (innerConfig?.user && innerConfig.key) {
        handleHealingInstrumentation(authResult, browserStackConfig, options.selfHeal);
        caps[browser].capabilities = this.updateCaps(authResult, options, caps[browser].capabilities);
      }
    }
  }
  handleMultiRemoteSetup(authResult, config, browserStackConfig, options, caps) {
    const browserNames = Object.keys(caps);
    for (let i = 0; i < browserNames.length; i++) {
      const browser = browserNames[i];
      this.addMultiRemoteCaps(authResult, config, browserStackConfig, options, caps, browser);
    }
  }
  async setup(config, browserStackConfig, options, caps, isMultiremote) {
    try {
      const innerConfig = getBrowserStackUserAndKey(config, options);
      if (innerConfig?.user && innerConfig.key) {
        const authResult = await this.authenticateUser(innerConfig.user, innerConfig.key);
        process.env[BSTACK_TCG_AUTH_RESULT] = JSON.stringify(authResult);
        if (!isMultiremote && SUPPORTED_BROWSERS_FOR_AI.includes(caps?.browserName?.toLowerCase())) {
          handleHealingInstrumentation(authResult, browserStackConfig, options.selfHeal);
          this.updateCaps(authResult, options, caps);
        } else if (isMultiremote) {
          this.handleMultiRemoteSetup(authResult, config, browserStackConfig, options, caps);
        }
      }
    } catch (err) {
      if (options.selfHeal === true) {
        BStackLogger.warn(`Error while initiliazing Browserstack healing Extension ${err}`);
      }
    }
    return caps;
  }
  async handleSelfHeal(options, browser) {
    if (SUPPORTED_BROWSERS_FOR_AI.includes(browser.capabilities?.browserName?.toLowerCase())) {
      const authInfo = this.authResult;
      if (Object.keys(authInfo).length === 0 && options.selfHeal === true) {
        BStackLogger.debug("TCG Auth result is empty");
        return;
      }
      const { isAuthenticated, sessionToken, defaultLogDataEnabled } = authInfo;
      if (isAuthenticated && (defaultLogDataEnabled === true || options.selfHeal === true)) {
        await this.setToken(browser.sessionId, sessionToken);
        if (browser.capabilities.browserName === "firefox") {
          await this.installFirefoxExtension(browser);
        }
        browser.overwriteCommand("findElement", async (orginalFunc, using, value) => {
          return await this.handleHealing(orginalFunc, using, value, browser, options);
        });
      }
    }
  }
  async selfHeal(options, caps, browser) {
    try {
      const multiRemoteBrowsers = Object.keys(caps).filter((e) => Object.keys(browser).includes(e));
      if (multiRemoteBrowsers.length > 0) {
        for (let i = 0; i < multiRemoteBrowsers.length; i++) {
          const remoteBrowser = browser[multiRemoteBrowsers[i]];
          await this.handleSelfHeal(options, remoteBrowser);
        }
      } else {
        await this.handleSelfHeal(options, browser);
      }
    } catch (err) {
      if (options.selfHeal === true) {
        BStackLogger.warn(`Error while setting up self-healing: ${err}. Disabling healing for this session.`);
      }
    }
  }
};
var ai_handler_default = new AiHandler();

// src/launcher.ts
var BrowserstackLauncherService = class {
  constructor(_options, capabilities, _config) {
    this._options = _options;
    this._config = _config;
    BStackLogger.clearLogFile();
    PercyLogger.clearLogFile();
    setupExitHandlers();
    this._config || (this._config = _options);
    this.browserStackConfig = config_default.getInstance(_options, _config);
    if (Array.isArray(capabilities)) {
      capabilities.flatMap((c) => {
        if ("alwaysMatch" in c) {
          return c.alwaysMatch;
        }
        if (Object.values(c).length > 0 && Object.values(c).every((c2) => typeof c2 === "object" && c2.capabilities)) {
          return Object.values(c).map((o) => o.capabilities);
        }
        return c;
      }).forEach((capability) => {
        if (!capability["bstack:options"]) {
          if (isBStackSession(this._config)) {
            const extensionCaps = Object.keys(capability).filter((cap) => cap.includes(":"));
            if (extensionCaps.length) {
              capability["bstack:options"] = { wdioService: BSTACK_SERVICE_VERSION };
              if (!isUndefined(capability["browserstack.accessibility"])) {
                this._accessibilityAutomation ||= isTrue(capability["browserstack.accessibility"]);
              } else if (isTrue(this._options.accessibility)) {
                capability["bstack:options"].accessibility = true;
              }
            } else if (shouldAddServiceVersion(this._config, this._options.testObservability)) {
              capability["browserstack.wdioService"] = BSTACK_SERVICE_VERSION;
            }
          }
          this._buildIdentifier = capability["browserstack.buildIdentifier"]?.toString();
          this._buildName = capability.build?.toString();
        } else {
          capability["bstack:options"].wdioService = BSTACK_SERVICE_VERSION;
          this._buildName = capability["bstack:options"].buildName;
          this._projectName = capability["bstack:options"].projectName;
          this._buildTag = capability["bstack:options"].buildTag;
          this._buildIdentifier = capability["bstack:options"].buildIdentifier;
          if (!isUndefined(capability["bstack:options"].accessibility)) {
            this._accessibilityAutomation ||= isTrue(capability["bstack:options"].accessibility);
          } else if (isTrue(this._options.accessibility)) {
            capability["bstack:options"].accessibility = isTrue(this._options.accessibility);
          }
        }
      });
    } else if (typeof capabilities === "object") {
      Object.entries(capabilities).forEach(([, caps]) => {
        if (!caps.capabilities["bstack:options"]) {
          if (isBStackSession(this._config)) {
            const extensionCaps = Object.keys(caps.capabilities).filter((cap) => cap.includes(":"));
            if (extensionCaps.length) {
              caps.capabilities["bstack:options"] = { wdioService: BSTACK_SERVICE_VERSION };
              if (!isUndefined(caps.capabilities["browserstack.accessibility"])) {
                this._accessibilityAutomation ||= isTrue(caps.capabilities["browserstack.accessibility"]);
              } else if (isTrue(this._options.accessibility)) {
                caps.capabilities["bstack:options"] = { wdioService: BSTACK_SERVICE_VERSION, accessibility: isTrue(this._options.accessibility) };
              }
            } else if (shouldAddServiceVersion(this._config, this._options.testObservability)) {
              caps.capabilities["browserstack.wdioService"] = BSTACK_SERVICE_VERSION;
            }
          }
          this._buildIdentifier = caps.capabilities["browserstack.buildIdentifier"];
        } else {
          const bstackOptions = caps.capabilities["bstack:options"];
          bstackOptions.wdioService = BSTACK_SERVICE_VERSION;
          this._buildName = bstackOptions.buildName;
          this._projectName = bstackOptions.projectName;
          this._buildTag = bstackOptions.buildTag;
          this._buildIdentifier = bstackOptions.buildIdentifier;
          if (!isUndefined(bstackOptions.accessibility)) {
            this._accessibilityAutomation ||= isTrue(bstackOptions.accessibility);
          } else if (isTrue(this._options.accessibility)) {
            bstackOptions.accessibility = isTrue(this._options.accessibility);
          }
        }
      });
    }
    this.browserStackConfig.buildIdentifier = this._buildIdentifier;
    this.browserStackConfig.buildName = this._buildName;
    if (process.env[PERF_MEASUREMENT_ENV]) {
      PerformanceTester.startMonitoring("performance-report-launcher.csv");
    }
    this._accessibilityAutomation ||= isTrue(this._options.accessibility);
    this._options.accessibility = this._accessibilityAutomation;
    this._options.testObservability = this._options.testObservability !== false;
    if (this._options.testObservability && // update files to run if it's a rerun
    process.env[RERUN_ENV] && process.env[RERUN_TESTS_ENV]) {
      this._config.specs = process.env[RERUN_TESTS_ENV].split(",");
    }
    try {
      CrashReporter.setConfigDetails(this._config, capabilities, this._options);
    } catch (error) {
      BStackLogger.error(`[Crash_Report_Upload] Config processing failed due to ${error}`);
    }
  }
  browserstackLocal;
  _buildName;
  _projectName;
  _buildTag;
  _buildIdentifier;
  _accessibilityAutomation;
  _percy;
  _percyBestPlatformCaps;
  browserStackConfig;
  async onWorkerStart(cid, caps) {
    try {
      if (this._options.percy && this._percyBestPlatformCaps) {
        const isThisBestPercyPlatform = ObjectsAreEqual(caps, this._percyBestPlatformCaps);
        if (isThisBestPercyPlatform) {
          process.env.BEST_PLATFORM_CID = cid;
        }
      }
    } catch (err) {
      PercyLogger.error(`Error while setting best platform for Percy snapshot at worker start ${err}`);
    }
  }
  async onPrepare(config, capabilities) {
    await sendStart(this.browserStackConfig);
    if (!shouldAddServiceVersion(this._config, this._options.testObservability, capabilities)) {
      try {
        if (capabilities.browserName) {
          capabilities = await ai_handler_default.setup(this._config, this.browserStackConfig, this._options, capabilities, false);
        } else if (Array.isArray(capabilities)) {
          for (let i = 0; i < capabilities.length; i++) {
            if (capabilities[i].browserName) {
              capabilities[i] = await ai_handler_default.setup(this._config, this.browserStackConfig, this._options, capabilities[i], false);
            }
          }
        } else if (isValidCapsForHealing(capabilities)) {
          capabilities = await ai_handler_default.setup(this._config, this.browserStackConfig, this._options, capabilities, true);
        }
      } catch (err) {
        if (this._options.selfHeal === true) {
          BStackLogger.warn(`Error while setting up Browserstack healing Extension ${err}. Disabling healing for this session.`);
        }
      }
    }
    if (!this._options.app) {
      BStackLogger.debug("app is not defined in browserstack-service config, skipping ...");
    } else {
      let app = {};
      const appConfig = this._options.app;
      try {
        app = await this._validateApp(appConfig);
      } catch (error) {
        throw new SevereServiceError(error);
      }
      if (VALID_APP_EXTENSION.includes(path11.extname(app.app))) {
        if (fs11.existsSync(app.app)) {
          const data = await this._uploadApp(app);
          BStackLogger.info(`app upload completed: ${JSON.stringify(data)}`);
          app.app = data.app_url;
        } else if (app.customId) {
          app.app = app.customId;
        } else {
          throw new SevereServiceError(`[Invalid app path] app path ${app.app} is not correct, Provide correct path to app under test`);
        }
      }
      BStackLogger.info(`Using app: ${app.app}`);
      this._updateCaps(capabilities, "app", app.app);
    }
    if (this._options.buildIdentifier) {
      this._buildIdentifier = this._options.buildIdentifier;
      this._updateCaps(capabilities, "buildIdentifier", this._buildIdentifier);
    }
    this._handleBuildIdentifier(capabilities);
    this._updateObjectTypeCaps(capabilities, "accessibilityOptions");
    if (this._accessibilityAutomation) {
      const scannerVersion = await createAccessibilityTestRun(this._options, this._config, {
        projectName: this._projectName,
        buildName: this._buildName,
        buildTag: this._buildTag,
        bstackServiceVersion: BSTACK_SERVICE_VERSION,
        buildIdentifier: this._buildIdentifier,
        accessibilityOptions: this._options.accessibilityOptions
      });
      if (scannerVersion) {
        process.env.BSTACK_A11Y_SCANNER_VERSION = scannerVersion;
      }
      BStackLogger.debug(`Accessibility scannerVersion ${scannerVersion}`);
    }
    if (this._options.accessibilityOptions) {
      const filteredOpts = Object.keys(this._options.accessibilityOptions).filter((key) => !NOT_ALLOWED_KEYS_IN_CAPS.includes(key)).reduce((opts2, key) => {
        return {
          ...opts2,
          [key]: this._options.accessibilityOptions?.[key]
        };
      }, {});
      this._updateObjectTypeCaps(capabilities, "accessibilityOptions", filteredOpts);
    } else if (isAccessibilityAutomationSession(this._accessibilityAutomation)) {
      this._updateObjectTypeCaps(capabilities, "accessibilityOptions", {});
    }
    if (this._options.testObservability) {
      BStackLogger.debug("Sending launch start event");
      await launchTestSession(this._options, this._config, {
        projectName: this._projectName,
        buildName: this._buildName,
        buildTag: this._buildTag,
        bstackServiceVersion: BSTACK_SERVICE_VERSION,
        buildIdentifier: this._buildIdentifier
      });
    }
    const shouldSetupPercy = this._options.percy || isUndefined(this._options.percy) && this._options.app;
    if (shouldSetupPercy) {
      try {
        const bestPlatformPercyCaps = getBestPlatformForPercySnapshot(capabilities);
        this._percyBestPlatformCaps = bestPlatformPercyCaps;
        await this.setupPercy(this._options, this._config, {
          projectName: this._projectName
        });
        this._updateBrowserStackPercyConfig();
      } catch (err) {
        PercyLogger.error(`Error while setting up Percy ${err}`);
      }
    }
    if (!this._options.browserstackLocal) {
      return BStackLogger.info("browserstackLocal is not enabled - skipping...");
    }
    const opts = {
      key: this._config.key,
      ...this._options.opts
    };
    this.browserstackLocal = new BrowserstackLocalLauncher.Local();
    this._updateCaps(capabilities, "local");
    if (opts.localIdentifier) {
      this._updateCaps(capabilities, "localIdentifier", opts.localIdentifier);
    }
    const obs = new PerformanceObserver2((list) => {
      const entry = list.getEntries()[0];
      BStackLogger.info(`Browserstack Local successfully started after ${entry.duration}ms`);
    });
    obs.observe({ entryTypes: ["measure"] });
    let timer;
    performance2.mark("tbTunnelStart");
    return Promise.race(
      [
        promisify2(this.browserstackLocal.start.bind(this.browserstackLocal))(opts),
        new Promise((resolve, reject) => {
          timer = setTimeout(function() {
            reject("Browserstack Local failed to start within 60 seconds!");
          }, 6e4);
        })
      ]
    ).then(function(result) {
      clearTimeout(timer);
      performance2.mark("tbTunnelEnd");
      performance2.measure("bootTime", "tbTunnelStart", "tbTunnelEnd");
      return Promise.resolve(result);
    }, function(err) {
      clearTimeout(timer);
      return Promise.reject(err);
    });
  }
  async onComplete() {
    BStackLogger.debug("Inside OnComplete hook..");
    if (isAccessibilityAutomationSession(this._accessibilityAutomation)) {
      await stopAccessibilityTestRun().catch((error) => {
        BStackLogger.error(`Exception in stop accessibility test run: ${error}`);
      });
    }
    if (this._options.testObservability) {
      BStackLogger.debug("Sending stop launch event");
      await stopBuildUpstream();
      if (process.env[TESTOPS_BUILD_ID_ENV]) {
        console.log(`
Visit https://observability.browserstack.com/builds/${process.env[TESTOPS_BUILD_ID_ENV]} to view build report, insights, and many more debugging information all at one place!
`);
      }
      this.browserStackConfig.testObservability.buildStopped = true;
      if (process.env[PERF_MEASUREMENT_ENV]) {
        await PerformanceTester.stopAndGenerate("performance-launcher.html");
        PerformanceTester.calculateTimes(["launchTestSession", "stopBuildUpstream"]);
        if (!process.env.START_TIME) {
          return;
        }
        const duration = (/* @__PURE__ */ new Date()).getTime() - new Date(process.env.START_TIME).getTime();
        BStackLogger.info(`Total duration is ${duration / 1e3} s`);
      }
    }
    await sendFinish(this.browserStackConfig);
    try {
      await this._uploadServiceLogs();
    } catch (error) {
      BStackLogger.debug(`Failed to upload BrowserStack WDIO Service logs ${error}`);
    }
    BStackLogger.clearLogger();
    if (this._options.percy) {
      await this.stopPercy();
      PercyLogger.clearLogger();
    }
    if (!this.browserstackLocal || !this.browserstackLocal.isRunning()) {
      return;
    }
    if (this._options.forcedStop) {
      return process.kill(this.browserstackLocal.pid);
    }
    let timer;
    return Promise.race(
      [
        new Promise((resolve, reject) => {
          this.browserstackLocal?.stop((err) => {
            if (err) {
              return reject(err);
            }
            resolve();
          });
        }),
        new Promise((resolve, reject) => {
          timer = setTimeout(
            () => reject(new Error("Browserstack Local failed to stop within 60 seconds!")),
            6e4
          );
        })
      ]
    ).then(function(result) {
      clearTimeout(timer);
      return Promise.resolve(result);
    }, function(err) {
      clearTimeout(timer);
      return Promise.reject(err);
    });
  }
  async setupPercy(options, config, bsConfig) {
    if (this._percy?.isRunning()) {
      return;
    }
    try {
      this._percy = await startPercy(options, config, bsConfig);
      if (!this._percy) {
        throw new Error("Could not start percy, check percy logs for info.");
      }
      PercyLogger.info("Percy started successfully");
      let signal = 0;
      const handler = async () => {
        signal++;
        signal === 1 && await this.stopPercy();
      };
      process.on("beforeExit", handler);
      process.on("SIGINT", handler);
      process.on("SIGTERM", handler);
    } catch (err) {
      PercyLogger.debug(`Error in percy setup ${err}`);
    }
  }
  async stopPercy() {
    if (!this._percy || !this._percy.isRunning()) {
      return;
    }
    try {
      await stopPercy(this._percy);
      PercyLogger.info("Percy stopped");
    } catch (err) {
      PercyLogger.error("Error occured while stopping percy : " + err);
    }
  }
  async _uploadApp(app) {
    BStackLogger.info(`uploading app ${app.app} ${app.customId ? `and custom_id: ${app.customId}` : ""} to browserstack`);
    const form = new FormData2();
    if (app.app) {
      const fileName = path11.basename(app.app);
      form.append("file", new FileStream(fs11.createReadStream(app.app)), fileName);
    }
    if (app.customId) {
      form.append("custom_id", app.customId);
    }
    const headers = {
      "Content-Type": "multipart/form-data",
      Authorization: getBasicAuthHeader(this._config.user, this._config.key)
    };
    const res = await fetch("https://api-cloud.browserstack.com/app-automate/upload", {
      method: "POST",
      body: form,
      headers
    });
    if (!res.ok) {
      throw new SevereServiceError(`app upload failed ${res.body}`);
    }
    return await res.json();
  }
  /**
   * @param  {String | AppConfig}  appConfig    <string>: should be "app file path" or "app_url" or "custom_id" or "shareable_id".
   *                                            <object>: only "path" and "custom_id" should coexist as multiple properties.
   */
  async _validateApp(appConfig) {
    const app = {};
    if (typeof appConfig === "string") {
      app.app = appConfig;
    } else if (typeof appConfig === "object" && Object.keys(appConfig).length) {
      if (Object.keys(appConfig).length > 2 || Object.keys(appConfig).length === 2 && (!appConfig.path || !appConfig.custom_id)) {
        throw new SevereServiceError(`keys ${Object.keys(appConfig)} can't co-exist as app values, use any one property from
                            {id<string>, path<string>, custom_id<string>, shareable_id<string>}, only "path" and "custom_id" can co-exist.`);
      }
      app.app = appConfig.id || appConfig.path || appConfig.custom_id || appConfig.shareable_id;
      app.customId = appConfig.custom_id;
    } else {
      throw new SevereServiceError("[Invalid format] app should be string or an object");
    }
    if (!app.app) {
      throw new SevereServiceError(`[Invalid app property] supported properties are {id<string>, path<string>, custom_id<string>, shareable_id<string>}.
                        For more details please visit https://www.browserstack.com/docs/app-automate/appium/set-up-tests/specify-app ')`);
    }
    return app;
  }
  async _uploadServiceLogs() {
    const clientBuildUuid = this._getClientBuildUuid();
    const response = await uploadLogs(getBrowserStackUser(this._config), getBrowserStackKey(this._config), clientBuildUuid);
    BStackLogger.logToFile(`Response - ${format(response)}`, "debug");
  }
  _updateObjectTypeCaps(capabilities, capType, value) {
    try {
      if (Array.isArray(capabilities)) {
        capabilities.flatMap((c) => {
          if ("alwaysMatch" in c) {
            return c.alwaysMatch;
          }
          if (Object.values(c).length > 0 && Object.values(c).every((c2) => typeof c2 === "object" && c2.capabilities)) {
            return Object.values(c).map((o) => o.capabilities);
          }
          return c;
        }).forEach((capability) => {
          if (!capability["bstack:options"]) {
            const extensionCaps = Object.keys(capability).filter((cap) => cap.includes(":"));
            if (extensionCaps.length) {
              if (capType === "accessibilityOptions" && value) {
                capability["bstack:options"] = { accessibilityOptions: value };
              }
            } else if (capType === "accessibilityOptions") {
              if (value) {
                const accessibilityOpts = { ...value };
                if (capability?.accessibility) {
                  accessibilityOpts.authToken = process.env.BSTACK_A11Y_JWT;
                  accessibilityOpts.scannerVersion = process.env.BSTACK_A11Y_SCANNER_VERSION;
                }
                capability["browserstack.accessibilityOptions"] = accessibilityOpts;
              } else {
                delete capability["browserstack.accessibilityOptions"];
              }
            }
          } else if (capType === "accessibilityOptions") {
            if (value) {
              const accessibilityOpts = { ...value };
              if (capability["bstack:options"].accessibility) {
                accessibilityOpts.authToken = process.env.BSTACK_A11Y_JWT;
                accessibilityOpts.scannerVersion = process.env.BSTACK_A11Y_SCANNER_VERSION;
              }
              capability["bstack:options"].accessibilityOptions = accessibilityOpts;
            } else {
              delete capability["bstack:options"].accessibilityOptions;
            }
          }
        });
      } else if (typeof capabilities === "object") {
        Object.entries(capabilities).forEach(([, caps]) => {
          if (!caps.capabilities["bstack:options"]) {
            const extensionCaps = Object.keys(caps.capabilities).filter((cap) => cap.includes(":"));
            if (extensionCaps.length) {
              if (capType === "accessibilityOptions" && value) {
                caps.capabilities["bstack:options"] = { accessibilityOptions: value };
              }
            } else if (capType === "accessibilityOptions") {
              if (value) {
                const accessibilityOpts = { ...value };
                if (caps.capabilities["browserstack.accessibility"]) {
                  accessibilityOpts.authToken = process.env.BSTACK_A11Y_JWT;
                  accessibilityOpts.scannerVersion = process.env.BSTACK_A11Y_SCANNER_VERSION;
                }
                caps.capabilities["browserstack.accessibilityOptions"] = accessibilityOpts;
              } else {
                delete caps.capabilities["browserstack.accessibilityOptions"];
              }
            }
          } else if (capType === "accessibilityOptions") {
            if (value) {
              const accessibilityOpts = { ...value };
              if (caps.capabilities["bstack:options"].accessibility) {
                accessibilityOpts.authToken = process.env.BSTACK_A11Y_JWT;
                accessibilityOpts.scannerVersion = process.env.BSTACK_A11Y_SCANNER_VERSION;
              }
              caps.capabilities["bstack:options"].accessibilityOptions = accessibilityOpts;
            } else {
              delete caps.capabilities["bstack:options"].accessibilityOptions;
            }
          }
        });
      }
    } catch (error) {
      BStackLogger.debug(`Exception while retrieving capability value. Error - ${error}`);
    }
  }
  _updateCaps(capabilities, capType, value) {
    if (Array.isArray(capabilities)) {
      capabilities.flatMap((c) => {
        if ("alwaysMatch" in c) {
          return c.alwaysMatch;
        }
        if (Object.values(c).length > 0 && Object.values(c).every((c2) => typeof c2 === "object" && c2.capabilities)) {
          return Object.values(c).map((o) => o.capabilities);
        }
        return c;
      }).forEach((capability) => {
        if (!capability["bstack:options"]) {
          const extensionCaps = Object.keys(capability).filter((cap) => cap.includes(":"));
          if (extensionCaps.length) {
            if (capType === "local") {
              capability["bstack:options"] = { local: true };
            } else if (capType === "app") {
              capability["appium:app"] = value;
            } else if (capType === "buildIdentifier" && value) {
              capability["bstack:options"] = { buildIdentifier: value };
            }
          } else if (capType === "local") {
            capability["browserstack.local"] = true;
          } else if (capType === "app") {
            capability.app = value;
          } else if (capType === "buildIdentifier") {
            if (value) {
              capability["browserstack.buildIdentifier"] = value;
            } else {
              delete capability["browserstack.buildIdentifier"];
            }
          } else if (capType === "localIdentifier") {
            capability["browserstack.localIdentifier"] = value;
          }
        } else if (capType === "local") {
          capability["bstack:options"].local = true;
        } else if (capType === "app") {
          capability["appium:app"] = value;
        } else if (capType === "buildIdentifier") {
          if (value) {
            capability["bstack:options"].buildIdentifier = value;
          } else {
            delete capability["bstack:options"].buildIdentifier;
          }
        } else if (capType === "localIdentifier") {
          capability["bstack:options"].localIdentifier = value;
        }
      });
    } else if (typeof capabilities === "object") {
      Object.entries(capabilities).forEach(([, caps]) => {
        if (!caps.capabilities["bstack:options"]) {
          const extensionCaps = Object.keys(caps.capabilities).filter((cap) => cap.includes(":"));
          if (extensionCaps.length) {
            if (capType === "local") {
              caps.capabilities["bstack:options"] = { local: true };
            } else if (capType === "app") {
              caps.capabilities["appium:app"] = value;
            } else if (capType === "buildIdentifier" && value) {
              caps.capabilities["bstack:options"] = { buildIdentifier: value };
            }
          } else if (capType === "local") {
            caps.capabilities["browserstack.local"] = true;
          } else if (capType === "app") {
            caps.capabilities["appium:app"] = value;
          } else if (capType === "buildIdentifier") {
            if (value) {
              caps.capabilities["browserstack.buildIdentifier"] = value;
            } else {
              delete caps.capabilities["browserstack.buildIdentifier"];
            }
          } else if (capType === "localIdentifier") {
            caps.capabilities["browserstack.localIdentifier"] = value;
          }
        } else if (capType === "local") {
          caps.capabilities["bstack:options"].local = true;
        } else if (capType === "app") {
          caps.capabilities["appium:app"] = value;
        } else if (capType === "buildIdentifier") {
          if (value) {
            caps.capabilities["bstack:options"].buildIdentifier = value;
          } else {
            delete caps.capabilities["bstack:options"].buildIdentifier;
          }
        } else if (capType === "localIdentifier") {
          caps.capabilities["bstack:options"].localIdentifier = value;
        }
      });
    } else {
      throw new SevereServiceError("Capabilities should be an object or Array!");
    }
  }
  _handleBuildIdentifier(capabilities) {
    if (!this._buildIdentifier) {
      return;
    }
    if ((!this._buildName || process.env.BROWSERSTACK_BUILD_NAME) && this._buildIdentifier) {
      this._updateCaps(capabilities, "buildIdentifier");
      BStackLogger.warn("Skipping buildIdentifier as buildName is not passed.");
      return;
    }
    if (this._buildIdentifier && this._buildIdentifier.includes("${DATE_TIME}")) {
      const formattedDate = new Intl.DateTimeFormat("en-GB", {
        month: "short",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        hour12: false
      }).format(/* @__PURE__ */ new Date()).replace(/ |, /g, "-");
      this._buildIdentifier = this._buildIdentifier.replace("${DATE_TIME}", formattedDate);
      this._updateCaps(capabilities, "buildIdentifier", this._buildIdentifier);
    }
    if (!this._buildIdentifier.includes("${BUILD_NUMBER}")) {
      return;
    }
    const ciInfo = getCiInfo();
    if (ciInfo !== null && ciInfo.build_number) {
      this._buildIdentifier = this._buildIdentifier.replace("${BUILD_NUMBER}", "CI " + ciInfo.build_number);
      this._updateCaps(capabilities, "buildIdentifier", this._buildIdentifier);
    } else {
      const localBuildNumber = this._getLocalBuildNumber();
      if (localBuildNumber) {
        this._buildIdentifier = this._buildIdentifier.replace("${BUILD_NUMBER}", localBuildNumber);
        this._updateCaps(capabilities, "buildIdentifier", this._buildIdentifier);
      }
    }
  }
  _updateBrowserStackPercyConfig() {
    const { percyAutoEnabled = false, percyCaptureMode, buildId, percy } = this._percy || {};
    this.browserStackConfig.percyCaptureMode = percyCaptureMode;
    this.browserStackConfig.percyBuildId = buildId;
    this.browserStackConfig.isPercyAutoEnabled = percyAutoEnabled;
    this._options.percy = percy;
    process.env.BROWSERSTACK_PERCY = String(percy);
    process.env.BROWSERSTACK_PERCY_CAPTURE_MODE = percyCaptureMode;
  }
  /**
   * @return {string} if buildName doesn't exist in json file, it will return 1
   *                  else returns corresponding value in json file (e.g. { "wdio-build": { "identifier" : 2 } } => 2 in this case)
   */
  _getLocalBuildNumber() {
    const browserstackFolderPath = path11.join(os5.homedir(), ".browserstack");
    try {
      if (!fs11.existsSync(browserstackFolderPath)) {
        fs11.mkdirSync(browserstackFolderPath);
      }
      const filePath = path11.join(browserstackFolderPath, ".build-name-cache.json");
      if (!fs11.existsSync(filePath)) {
        fs11.appendFileSync(filePath, JSON.stringify({}));
      }
      const buildCacheFileData = fs11.readFileSync(filePath);
      const parsedBuildCacheFileData = JSON.parse(buildCacheFileData.toString());
      if (this._buildName && this._buildName in parsedBuildCacheFileData) {
        const prevIdentifier = parseInt(parsedBuildCacheFileData[this._buildName].identifier);
        const newIdentifier2 = prevIdentifier + 1;
        this._updateLocalBuildCache(filePath, this._buildName, newIdentifier2);
        return newIdentifier2.toString();
      }
      const newIdentifier = 1;
      this._updateLocalBuildCache(filePath, this._buildName, 1);
      return newIdentifier.toString();
    } catch (error) {
      return null;
    }
  }
  _updateLocalBuildCache(filePath, buildName, buildIdentifier) {
    if (!buildName || !filePath) {
      return;
    }
    const jsonContent = JSON.parse(fs11.readFileSync(filePath).toString());
    jsonContent[buildName] = { "identifier": buildIdentifier };
    fs11.writeFileSync(filePath, JSON.stringify(jsonContent));
  }
  _getClientBuildUuid() {
    if (process.env[TESTOPS_BUILD_ID_ENV]) {
      return process.env[TESTOPS_BUILD_ID_ENV];
    }
    const uuid = uuidv4();
    BStackLogger.logToFile(`If facing any issues, please contact BrowserStack support with the Build Run Id - ${uuid}`, "info");
    return uuid;
  }
};

// src/insights-handler.ts
import path13 from "node:path";
import { v4 as uuidv43 } from "uuid";

// src/reporter.ts
import path12 from "node:path";
import WDIOReporter from "@wdio/reporter";
import * as url2 from "node:url";
import { v4 as uuidv42 } from "uuid";

// src/request-handler.ts
var RequestQueueHandler = class _RequestQueueHandler {
  queue = [];
  callback;
  pollEventBatchInterval;
  static tearDownInvoked = false;
  static instance;
  // making it private to use singleton pattern
  constructor(callback) {
    this.callback = callback;
    this.startEventBatchPolling();
  }
  static getInstance(callback) {
    if (!_RequestQueueHandler.instance && callback) {
      _RequestQueueHandler.instance = new _RequestQueueHandler(callback);
    }
    return _RequestQueueHandler.instance;
  }
  add(event) {
    if (!process.env[TESTOPS_BUILD_COMPLETED_ENV]) {
      throw new Error("Observability build start not completed yet.");
    }
    this.queue.push(event);
    BStackLogger.debug(`Added data to request queue. Queue length = ${this.queue.length}`);
    const shouldProceed = this.shouldProceed();
    if (shouldProceed) {
      this.sendBatch().catch((e) => {
        BStackLogger.debug("Exception in sending batch: " + e);
      });
    }
  }
  async shutdown() {
    BStackLogger.debug("shutdown started");
    this.removeEventBatchPolling("Shutting down");
    while (this.queue.length > 0) {
      const data = this.queue.splice(0, DATA_BATCH_SIZE);
      await this.callCallback(data, "SHUTDOWN_QUEUE");
    }
    BStackLogger.debug("shutdown ended");
  }
  startEventBatchPolling() {
    this.pollEventBatchInterval = setInterval(this.sendBatch.bind(this), DATA_BATCH_INTERVAL);
  }
  async sendBatch() {
    const data = this.queue.splice(0, DATA_BATCH_SIZE);
    if (data.length === 0) {
      return;
    }
    BStackLogger.debug(`Sending data from request queue. Data length = ${data.length}, Queue length after removal = ${this.queue.length}`);
    await this.callCallback(data, "INTERVAL_QUEUE");
  }
  callCallback = async (data, kind) => {
    BStackLogger.debug("calling callback with kind " + kind);
    this.callback && await this.callback(data);
  };
  resetEventBatchPolling() {
    this.removeEventBatchPolling("Resetting");
    this.startEventBatchPolling();
  }
  removeEventBatchPolling(tag) {
    if (this.pollEventBatchInterval) {
      BStackLogger.debug(`${tag} request queue`);
      clearInterval(this.pollEventBatchInterval);
    }
  }
  shouldProceed() {
    if (_RequestQueueHandler.tearDownInvoked) {
      BStackLogger.debug("Force request-queue shutdown, as test run event is received after teardown");
      return true;
    }
    return this.queue.length >= DATA_BATCH_SIZE;
  }
};

// src/testOps/requestUtils.ts
async function uploadEventData(eventData, eventUrl = DATA_EVENT_ENDPOINT) {
  let logTag = "BATCH_UPLOAD";
  if (!Array.isArray(eventData)) {
    logTag = getLogTag(eventData.event_type);
  }
  if (eventUrl === DATA_SCREENSHOT_ENDPOINT) {
    logTag = "screenshot_upload";
  }
  if (!process.env[TESTOPS_BUILD_COMPLETED_ENV]) {
    throw new Error("Build start not completed yet");
  }
  if (!process.env[TESTOPS_JWT_ENV]) {
    BStackLogger.debug(`[${logTag}] Missing Authentication Token/ Build ID`);
    throw new Error("Token/buildID is undefined, build creation might have failed");
  }
  try {
    const url3 = `${DATA_ENDPOINT}/${eventUrl}`;
    const data = await fetchWrap(url3, {
      method: "POST",
      headers: {
        ...DEFAULT_REQUEST_CONFIG.headers,
        "Authorization": `Bearer ${process.env[TESTOPS_JWT_ENV]}`
      },
      body: JSON.stringify(eventData)
    });
    BStackLogger.debug(`[${logTag}] Success response: ${JSON.stringify(await data.json())}`);
  } catch (error) {
    BStackLogger.debug(`[${logTag}] Failed. Error: ${error}`);
    throw error;
  }
}
function sendScreenshots(eventData) {
  return uploadEventData(eventData, DATA_SCREENSHOT_ENDPOINT);
}

// src/testOps/listener.ts
var Listener = class _Listener {
  static instance;
  usageStats = usageStats_default.getInstance();
  testStartedStats = this.usageStats.testStartedStats;
  testFinishedStats = this.usageStats.testFinishedStats;
  hookStartedStats = this.usageStats.hookStartedStats;
  hookFinishedStats = this.usageStats.hookFinishedStats;
  cbtSessionStats = this.usageStats.cbtSessionStats;
  logEvents = this.usageStats.logStats;
  requestBatcher;
  pendingUploads = 0;
  // Making the constructor private to use singleton pattern
  constructor() {
  }
  static getInstance() {
    if (!_Listener.instance) {
      _Listener.instance = new _Listener();
    }
    return _Listener.instance;
  }
  async onWorkerEnd() {
    try {
      await this.uploadPending();
      await this.teardown();
    } catch (e) {
      BStackLogger.debug("Exception in onWorkerEnd: " + e);
    }
  }
  async uploadPending(waitTimeout = DEFAULT_WAIT_TIMEOUT_FOR_PENDING_UPLOADS, waitInterval = DEFAULT_WAIT_INTERVAL_FOR_PENDING_UPLOADS) {
    if (this.pendingUploads <= 0 || waitTimeout <= 0) {
      return;
    }
    await sleep(waitInterval);
    return this.uploadPending(waitTimeout - waitInterval);
  }
  async teardown() {
    BStackLogger.debug("teardown started");
    RequestQueueHandler.tearDownInvoked = true;
    await this.requestBatcher?.shutdown();
    BStackLogger.debug("teardown ended");
  }
  hookStarted(hookData) {
    try {
      this.hookStartedStats.triggered();
      this.sendBatchEvents(this.getEventForHook("HookRunStarted", hookData));
    } catch (e) {
      this.hookStartedStats.failed();
      throw e;
    }
  }
  hookFinished(hookData) {
    try {
      this.hookFinishedStats.triggered(hookData.result);
      this.sendBatchEvents(this.getEventForHook("HookRunFinished", hookData));
    } catch (e) {
      this.hookFinishedStats.failed(hookData.result);
      throw e;
    }
  }
  testStarted(testData) {
    try {
      this.testStartedStats.triggered();
      this.sendBatchEvents(this.getEventForHook("TestRunStarted", testData));
    } catch (e) {
      this.testStartedStats.failed();
      throw e;
    }
  }
  testFinished(testData) {
    try {
      this.testFinishedStats.triggered(testData.result);
      this.sendBatchEvents(this.getEventForHook("TestRunFinished", testData));
    } catch (e) {
      this.testFinishedStats.failed(testData.result);
      throw e;
    }
  }
  logCreated(logs) {
    try {
      this.markLogs("triggered", logs);
      this.sendBatchEvents({
        event_type: "LogCreated",
        logs
      });
    } catch (e) {
      this.markLogs("failed", logs);
      throw e;
    }
  }
  async onScreenshot(jsonArray) {
    if (!this.shouldSendEvents()) {
      return;
    }
    try {
      this.markLogs("triggered", jsonArray);
      this.pendingUploads += 1;
      await sendScreenshots([{
        event_type: "LogCreated",
        logs: jsonArray
      }]);
      this.markLogs("success", jsonArray);
    } catch (e) {
      this.markLogs("failed", jsonArray);
      throw e;
    } finally {
      this.pendingUploads -= 1;
    }
  }
  cbtSessionCreated(data) {
    try {
      this.cbtSessionStats.triggered();
      this.sendBatchEvents({ event_type: "CBTSessionCreated", test_run: data });
    } catch (e) {
      this.cbtSessionStats.failed();
      throw e;
    }
  }
  markLogs(status, data) {
    if (!data) {
      BStackLogger.debug("No log data");
      return;
    }
    try {
      for (const _log of data) {
        const kind = _log.kind;
        this.logEvents.mark(status, LOG_KIND_USAGE_MAP[kind] || kind);
      }
    } catch (e) {
      BStackLogger.debug("Exception in marking logs status " + e);
      throw e;
    }
  }
  getResult(jsonObject, kind) {
    const runStr = kind === "test" ? "test_run" : "hook_run";
    const runData = jsonObject[runStr];
    return runData?.result;
  }
  shouldSendEvents() {
    return isTrue(process.env[TESTOPS_BUILD_COMPLETED_ENV]);
  }
  sendBatchEvents(jsonObject) {
    if (!this.shouldSendEvents()) {
      return;
    }
    if (!this.requestBatcher) {
      this.requestBatcher = RequestQueueHandler.getInstance(async (data) => {
        BStackLogger.debug("callback: called with events " + data.length);
        try {
          this.pendingUploads += 1;
          await batchAndPostEvents(DATA_BATCH_ENDPOINT, "BATCH_DATA", data);
          BStackLogger.debug("callback: marking events success " + data.length);
          this.eventsSuccess(data);
        } catch (e) {
          BStackLogger.debug("callback: marking events failed " + data.length);
          this.eventsFailed(data);
        } finally {
          this.pendingUploads -= 1;
        }
      });
    }
    this.requestBatcher.add(jsonObject);
  }
  eventsFailed(events) {
    for (const event of events) {
      const eventType = event.event_type;
      if (eventType === "TestRunStarted") {
        this.testStartedStats.failed();
      } else if (eventType === "TestRunFinished") {
        this.testFinishedStats.failed(this.getResult(event, "test"));
      } else if (eventType === "HookRunStarted") {
        this.hookStartedStats.failed();
      } else if (eventType === "HookRunFinished") {
        this.hookFinishedStats.failed(this.getResult(event, "hook"));
      } else if (eventType === "CBTSessionCreated") {
        this.cbtSessionStats.failed();
      } else if (eventType === "LogCreated") {
        this.markLogs("failed", event.logs);
      }
    }
  }
  eventsSuccess(events) {
    for (const event of events) {
      const eventType = event.event_type;
      if (eventType === "TestRunStarted") {
        this.testStartedStats.success();
      } else if (eventType === "TestRunFinished") {
        this.testFinishedStats.success(this.getResult(event, "test"));
      } else if (eventType === "HookRunStarted") {
        this.hookStartedStats.success();
      } else if (eventType === "HookRunFinished") {
        this.hookFinishedStats.success(this.getResult(event, "hook"));
      } else if (eventType === "CBTSessionCreated") {
        this.cbtSessionStats.success();
      } else if (eventType === "LogCreated") {
        this.markLogs("success", event.logs);
      }
    }
  }
  getEventForHook(eventType, data) {
    return {
      event_type: eventType,
      [data.type === "hook" ? "hook_run" : "test_run"]: data
    };
  }
};
var listener_default = Listener;

// src/reporter.ts
var _TestReporter = class __TestReporter extends WDIOReporter {
  _capabilities = {};
  _config;
  _observability = true;
  _sessionId;
  _suiteName;
  _suites = [];
  static _tests = {};
  _gitConfigPath;
  _gitConfigured = false;
  _currentHook = {};
  _currentTest = {};
  _userCaps = {};
  listener = listener_default.getInstance();
  async onRunnerStart(runnerStats) {
    this._capabilities = runnerStats.capabilities;
    this._userCaps = this.getUserCaps(runnerStats);
    this._config = runnerStats.config;
    this._sessionId = runnerStats.sessionId;
    if (typeof this._config.testObservability !== "undefined") {
      this._observability = this._config.testObservability;
    }
    await this.configureGit();
    this.registerListeners();
  }
  getUserCaps(runnerStats) {
    return runnerStats.capabilities;
  }
  registerListeners() {
    if (this._config?.framework !== "jasmine") {
      return;
    }
    process.removeAllListeners(`bs:addLog:${process.pid}`);
    process.on(`bs:addLog:${process.pid}`, this.appendTestItemLog.bind(this));
  }
  async appendTestItemLog(stdLog) {
    if (this._currentHook.uuid && !this._currentHook.finished) {
      stdLog.hook_run_uuid = this._currentHook.uuid;
    } else if (this._currentTest.uuid) {
      stdLog.test_run_uuid = this._currentTest.uuid;
    }
    if (stdLog.hook_run_uuid || stdLog.test_run_uuid) {
      this.listener.logCreated([stdLog]);
    }
  }
  setCurrentHook(hookDetails) {
    if (hookDetails.finished) {
      if (this._currentHook.uuid === hookDetails.uuid) {
        this._currentHook.finished = true;
      }
      return;
    }
    this._currentHook = {
      uuid: hookDetails.uuid,
      finished: false
    };
  }
  async configureGit() {
    if (this._gitConfigured) {
      return;
    }
    const gitMeta = await getGitMetaData();
    if (gitMeta) {
      this._gitConfigPath = gitMeta.root;
    }
    this._gitConfigured = true;
  }
  static getTests() {
    return __TestReporter._tests;
  }
  onSuiteStart(suiteStats) {
    let filename = suiteStats.file;
    if (this._config?.framework === "jasmine") {
      try {
        if (suiteStats.file.startsWith("file://")) {
          filename = url2.fileURLToPath(suiteStats.file);
        }
        if (filename === "unknown spec file") {
          filename = this._suiteName || suiteStats.file;
        }
      } catch (e) {
        BStackLogger.debug("Error in decoding file name of suite");
      }
    }
    this._suiteName = filename;
    this._suites.push(suiteStats);
  }
  onSuiteEnd() {
    this._suites.pop();
  }
  needToSendData(testType, event) {
    if (!this._observability) {
      return false;
    }
    switch (this._config?.framework) {
      case "mocha":
        return event === "skip";
      case "cucumber":
        return false;
      case "jasmine":
        return event !== "skip";
      default:
        return false;
    }
  }
  async onTestEnd(testStats) {
    if (!this.needToSendData("test", "end")) {
      return;
    }
    if (testStats.fullTitle === "<unknown test>") {
      return;
    }
    testStats.end ||= /* @__PURE__ */ new Date();
    this.listener.testFinished(await this.getRunData(testStats, "TestRunFinished"));
  }
  async onTestStart(testStats) {
    if (!this.needToSendData("test", "start")) {
      return;
    }
    if (testStats.fullTitle === "<unknown test>") {
      return;
    }
    const uuid = uuidv42();
    this._currentTest.uuid = uuid;
    __TestReporter._tests[testStats.fullTitle] = {
      uuid
    };
    this.listener.testStarted(await this.getRunData(testStats, "TestRunStarted"));
  }
  async onHookStart(hookStats) {
    if (!this.needToSendData("hook", "start")) {
      return;
    }
    const identifier = this.getHookIdentifier(hookStats);
    const hookId = uuidv42();
    this.setCurrentHook({ uuid: hookId });
    __TestReporter._tests[identifier] = {
      uuid: hookId,
      startedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    this.listener.hookStarted(await this.getRunData(hookStats, "HookRunStarted"));
  }
  async onHookEnd(hookStats) {
    if (!this.needToSendData("hook", "end")) {
      return;
    }
    const identifier = this.getHookIdentifier(hookStats);
    if (__TestReporter._tests[identifier]) {
      __TestReporter._tests[identifier].finishedAt = (/* @__PURE__ */ new Date()).toISOString();
    } else {
      __TestReporter._tests[identifier] = {
        finishedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
    this.setCurrentHook({ uuid: __TestReporter._tests[identifier].uuid, finished: true });
    if (!hookStats.state && !hookStats.error) {
      hookStats.state = "passed";
    }
    this.listener.hookFinished(await this.getRunData(hookStats, "HookRunFinished"));
  }
  getHookIdentifier(hookStats) {
    return `${hookStats.title} for ${this._suites.at(-1)?.title}`;
  }
  async onTestSkip(testStats) {
    if (!this.needToSendData("test", "skip")) {
      return;
    }
    testStats.start ||= /* @__PURE__ */ new Date();
    testStats.end ||= /* @__PURE__ */ new Date();
    this.listener.testFinished(await this.getRunData(testStats, "TestRunSkipped"));
  }
  async getRunData(testStats, eventType) {
    const framework = this._config?.framework;
    const scopes = this._suites.map((s) => s.title);
    const identifier = testStats.type === "test" ? testStats.fullTitle : this.getHookIdentifier(testStats);
    const testMetaData = __TestReporter._tests[identifier];
    const scope = testStats.type === "test" ? testStats.fullTitle : `${this._suites[0].title} - ${testStats.title}`;
    const suiteFileName = this._suiteName || (this.specs?.length > 0 ? this.specs[this.specs.length - 1]?.replace("file:", "") : void 0);
    await this.configureGit();
    const testData = {
      uuid: testMetaData ? testMetaData.uuid : uuidv42(),
      type: testStats.type,
      name: testStats.title,
      body: {
        lang: "webdriverio",
        code: null
      },
      scope,
      scopes,
      identifier,
      file_name: suiteFileName ? path12.relative(process.cwd(), suiteFileName) : void 0,
      location: suiteFileName ? path12.relative(process.cwd(), suiteFileName) : void 0,
      vc_filepath: this._gitConfigPath && suiteFileName ? path12.relative(this._gitConfigPath, suiteFileName) : void 0,
      started_at: testStats.start && testStats.start.toISOString(),
      finished_at: testStats.end && testStats.end.toISOString(),
      framework,
      duration_in_ms: testStats._duration,
      result: testStats.state
    };
    if (testStats.type === "test") {
      testData.retries = { limit: testStats.retries || 0, attempts: testStats.retries || 0 };
    }
    if (eventType.startsWith("TestRun") || eventType === "HookRunStarted") {
      const cloudProvider = getCloudProvider({ options: { hostname: this._config?.hostname } });
      testData.integrations = {};
      testData.integrations[cloudProvider] = {
        capabilities: this._capabilities,
        session_id: this._sessionId,
        browser: this._capabilities?.browserName,
        browser_version: this._capabilities?.browserVersion,
        platform: this._capabilities?.platformName,
        platform_version: getPlatformVersion(this._userCaps)
      };
    }
    if (eventType === "TestRunFinished" || eventType === "HookRunFinished") {
      const { error } = testStats;
      const failed = testStats.state === "failed";
      if (failed) {
        testData.result = error && error.message && error.message.includes("sync skip; aborting execution") ? "ignore" : "failed";
        if (error && testData.result !== "skipped") {
          testData.failure = [{ backtrace: [removeAnsiColors(error.message)] }];
          testData.failure_reason = removeAnsiColors(error.message);
          testData.failure_type = error.message === null ? null : error.message.toString().match(/AssertionError/) ? "AssertionError" : "UnhandledError";
        }
      }
    }
    if (eventType === "TestRunSkipped") {
      eventType = "TestRunFinished";
    }
    if (eventType.match(/HookRun/)) {
      testData.hook_type = testData.name?.toLowerCase() ? getHookType(testData.name.toLowerCase()) : "undefined";
    }
    return testData;
  }
};
var TestReporter = o11yClassErrorHandler(_TestReporter);
var reporter_default = TestReporter;

// src/insights-handler.ts
var _InsightsHandler = class {
  constructor(_browser, _framework, _userCaps, _options) {
    this._browser = _browser;
    this._framework = _framework;
    const caps = this._browser.capabilities;
    const sessionId = this._browser.sessionId;
    this._userCaps = _userCaps;
    this._platformMeta = {
      browserName: caps.browserName,
      browserVersion: caps?.browserVersion,
      platformName: caps?.platformName,
      caps,
      sessionId,
      product: getObservabilityProduct(_options, this._isAppAutomate())
    };
    this.registerListeners();
  }
  _tests = {};
  _hooks = {};
  _platformMeta;
  _commands = {};
  _gitConfigPath;
  _suiteFile;
  _currentTest = {};
  _currentHook = {};
  _cucumberData = {
    stepsStarted: false,
    scenariosStarted: false,
    steps: []
  };
  _userCaps = {};
  listener = listener_default.getInstance();
  _currentTestId;
  _cbtQueue = [];
  _isAppAutomate() {
    const browserDesiredCapabilities = this._browser?.capabilities ?? {};
    const desiredCapabilities = this._userCaps ?? {};
    return !!browserDesiredCapabilities["appium:app"] || !!desiredCapabilities["appium:app"] || !!desiredCapabilities["appium:options"]?.app;
  }
  registerListeners() {
    if (!(this._framework === "mocha" || this._framework === "cucumber")) {
      return;
    }
    process.removeAllListeners(`bs:addLog:${process.pid}`);
    process.on(`bs:addLog:${process.pid}`, this.appendTestItemLog.bind(this));
  }
  setSuiteFile(filename) {
    this._suiteFile = filename;
  }
  async before() {
    if (isBrowserstackSession(this._browser)) {
      await this._browser.execute(`browserstack_executor: ${JSON.stringify({
        action: "annotate",
        arguments: {
          data: `ObservabilitySync:${Date.now()}`,
          level: "debug"
        }
      })}`);
    }
    const gitMeta = await getGitMetaData();
    if (gitMeta) {
      this._gitConfigPath = gitMeta.root;
    }
  }
  getCucumberHookType(test) {
    let hookType = null;
    if (!test) {
      hookType = this._cucumberData.scenariosStarted ? "AFTER_ALL" : "BEFORE_ALL";
    } else if (!this._cucumberData.stepsStarted) {
      hookType = "BEFORE_EACH";
    } else if (this._cucumberData.steps?.length > 0) {
    } else {
      hookType = "AFTER_EACH";
    }
    return hookType;
  }
  getCucumberHookName(hookType) {
    switch (hookType) {
      case "BEFORE_EACH":
      case "AFTER_EACH":
        return `${hookType} for ${this._cucumberData.scenario?.name}`;
      case "BEFORE_ALL":
      case "AFTER_ALL":
        return `${hookType} for ${this._cucumberData.feature?.name}`;
    }
    return "";
  }
  getCucumberHookUniqueId(hookType, hook) {
    switch (hookType) {
      case "BEFORE_EACH":
      case "AFTER_EACH":
        return hook.hookId;
      case "BEFORE_ALL":
      case "AFTER_ALL":
        return `${hookType} for ${this.getCucumberFeatureUniqueId()}`;
    }
    return null;
  }
  getCucumberFeatureUniqueId() {
    const { uri, feature } = this._cucumberData;
    return `${uri}:${feature?.name}`;
  }
  setCurrentHook(hookDetails) {
    if (hookDetails.finished) {
      if (this._currentHook.uuid === hookDetails.uuid) {
        this._currentHook.finished = true;
      }
      return;
    }
    this._currentHook = {
      uuid: hookDetails.uuid,
      finished: false
    };
  }
  async sendScenarioObjectSkipped(scenario, feature, uri) {
    const testMetaData = {
      uuid: uuidv43(),
      startedAt: (/* @__PURE__ */ new Date()).toISOString(),
      finishedAt: (/* @__PURE__ */ new Date()).toISOString(),
      scenario: {
        name: scenario.name
      },
      feature: {
        path: uri,
        name: feature.name,
        description: feature.description
      },
      steps: scenario.steps.map((step) => {
        return {
          id: step.id,
          text: step.text,
          keyword: step.keyword,
          result: "skipped"
        };
      })
    };
    this.listener.testFinished(this.getTestRunDataForCucumber(null, "TestRunSkipped", testMetaData));
  }
  async processCucumberHook(test, params, result) {
    const hookType = this.getCucumberHookType(test);
    if (!hookType) {
      return;
    }
    const { event, hookUUID } = params;
    const hookId = this.getCucumberHookUniqueId(hookType, test);
    if (!hookId) {
      return;
    }
    if (event === "before") {
      this.setCurrentHook({ uuid: hookUUID });
      const hookMetaData = {
        uuid: hookUUID,
        startedAt: (/* @__PURE__ */ new Date()).toISOString(),
        testRunId: this._currentTest.uuid,
        hookType
      };
      this._tests[hookId] = hookMetaData;
      this.listener.hookStarted(this.getHookRunDataForCucumber(hookMetaData, "HookRunStarted"));
    } else {
      this._tests[hookId].finishedAt = (/* @__PURE__ */ new Date()).toISOString();
      this.setCurrentHook({ uuid: this._tests[hookId].uuid, finished: true });
      this.listener.hookFinished(this.getHookRunDataForCucumber(this._tests[hookId], "HookRunFinished", result));
      if (hookType === "BEFORE_ALL" && result && !result.passed) {
        const { feature, uri } = this._cucumberData;
        if (!feature) {
          return;
        }
        feature.children.map(async (childObj) => {
          if (childObj.rule) {
            childObj.rule.children.map(async (scenarioObj) => {
              if (scenarioObj.scenario) {
                await this.sendScenarioObjectSkipped(scenarioObj.scenario, feature, uri);
              }
            });
          } else if (childObj.scenario) {
            await this.sendScenarioObjectSkipped(childObj.scenario, feature, uri);
          }
        });
      }
    }
  }
  async beforeHook(test, context) {
    if (!frameworkSupportsHook("before", this._framework)) {
      return;
    }
    const hookUUID = uuidv43();
    if (this._framework === "cucumber") {
      test = test;
      await this.processCucumberHook(test, { event: "before", hookUUID });
      return;
    }
    test = test;
    const fullTitle = getUniqueIdentifier(test, this._framework);
    this._tests[fullTitle] = {
      uuid: hookUUID,
      startedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    this.setCurrentHook({ uuid: hookUUID });
    this.attachHookData(context, hookUUID);
    this.listener.hookStarted(this.getRunData(test, "HookRunStarted"));
  }
  async afterHook(test, result) {
    if (!frameworkSupportsHook("after", this._framework)) {
      return;
    }
    if (this._framework === "cucumber") {
      await this.processCucumberHook(test, { event: "after" }, result);
      return;
    }
    test = test;
    const fullTitle = getUniqueIdentifier(test, this._framework);
    if (this._tests[fullTitle]) {
      this._tests[fullTitle].finishedAt = (/* @__PURE__ */ new Date()).toISOString();
    } else {
      this._tests[fullTitle] = {
        finishedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
    this.setCurrentHook({ uuid: this._tests[fullTitle].uuid, finished: true });
    this.listener.hookFinished(this.getRunData(test, "HookRunFinished", result));
    const hookType = getHookType(test.title);
    if (!result.passed && (hookType === "BEFORE_EACH" || hookType === "BEFORE_ALL" || hookType === "AFTER_EACH")) {
      const sendTestSkip = async (skippedTest) => {
        if (skippedTest.state === void 0) {
          const fullTitle2 = `${skippedTest.parent.title} - ${skippedTest.title}`;
          this._tests[fullTitle2] = {
            uuid: uuidv43(),
            startedAt: (/* @__PURE__ */ new Date()).toISOString(),
            finishedAt: (/* @__PURE__ */ new Date()).toISOString()
          };
          this.listener.testFinished(this.getRunData(skippedTest, "TestRunSkipped"));
        }
      };
      const sendSuiteSkipped = async (suite) => {
        for (const skippedTest of suite.tests) {
          await sendTestSkip(skippedTest);
        }
        for (const skippedSuite of suite.suites) {
          await sendSuiteSkipped(skippedSuite);
        }
      };
      await sendSuiteSkipped(test.ctx.test.parent);
    }
  }
  getHookRunDataForCucumber(hookData, eventType, result) {
    const { uri, feature } = this._cucumberData;
    const testData = {
      uuid: hookData.uuid,
      type: "hook",
      name: this.getCucumberHookName(hookData.hookType),
      body: {
        lang: "webdriverio",
        code: null
      },
      started_at: hookData.startedAt,
      finished_at: hookData.finishedAt,
      hook_type: hookData.hookType,
      test_run_id: hookData.testRunId,
      scope: feature?.name,
      scopes: [feature?.name || ""],
      file_name: uri ? path13.relative(process.cwd(), uri) : void 0,
      location: uri ? path13.relative(process.cwd(), uri) : void 0,
      vc_filepath: this._gitConfigPath && uri ? path13.relative(this._gitConfigPath, uri) : void 0,
      result: "pending",
      framework: this._framework
    };
    if (eventType === "HookRunFinished" && result) {
      testData.result = result.passed ? "passed" : "failed";
      testData.retries = result.retries;
      testData.duration_in_ms = result.duration;
      if (!result.passed) {
        Object.assign(testData, getFailureObject(result.error));
      }
    }
    if (eventType === "HookRunStarted") {
      testData.integrations = {};
      if (this._browser && this._platformMeta) {
        const provider = getCloudProvider(this._browser);
        testData.integrations[provider] = this.getIntegrationsObject();
      }
    }
    return testData;
  }
  async beforeTest(test) {
    const uuid = uuidv43();
    this._currentTest = {
      test,
      uuid
    };
    if (this._framework !== "mocha") {
      return;
    }
    const fullTitle = getUniqueIdentifier(test, this._framework);
    this._tests[fullTitle] = {
      uuid,
      startedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    this.listener.testStarted(this.getRunData(test, "TestRunStarted"));
  }
  async afterTest(test, result) {
    if (this._framework !== "mocha") {
      return;
    }
    const fullTitle = getUniqueIdentifier(test, this._framework);
    this._tests[fullTitle] = {
      ...this._tests[fullTitle] || {},
      finishedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    this.flushCBTDataQueue();
    this.listener.testFinished(this.getRunData(test, "TestRunFinished", result));
  }
  /**
    * Cucumber Only
    */
  async beforeFeature(uri, feature) {
    this._cucumberData.scenariosStarted = false;
    this._cucumberData.feature = feature;
    this._cucumberData.uri = uri;
  }
  async beforeScenario(world) {
    const uuid = uuidv43();
    this._currentTest = {
      uuid
    };
    this._cucumberData.scenario = world.pickle;
    this._cucumberData.scenariosStarted = true;
    this._cucumberData.stepsStarted = false;
    const pickleData = world.pickle;
    const gherkinDocument = world.gherkinDocument;
    const featureData = gherkinDocument.feature;
    const uniqueId = getUniqueIdentifierForCucumber(world);
    const testMetaData = {
      uuid,
      startedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    if (pickleData) {
      testMetaData.scenario = {
        name: pickleData.name
      };
    }
    if (gherkinDocument && featureData) {
      testMetaData.feature = {
        path: gherkinDocument.uri,
        name: featureData.name,
        description: featureData.description
      };
    }
    this._tests[uniqueId] = testMetaData;
    this.listener.testStarted(this.getTestRunDataForCucumber(world, "TestRunStarted"));
  }
  async afterScenario(world) {
    this._cucumberData.scenario = void 0;
    this.flushCBTDataQueue();
    this.listener.testFinished(this.getTestRunDataForCucumber(world, "TestRunFinished"));
  }
  async beforeStep(step, scenario) {
    this._cucumberData.stepsStarted = true;
    this._cucumberData.steps.push(step);
    const uniqueId = getUniqueIdentifierForCucumber({ pickle: scenario });
    const testMetaData = this._tests[uniqueId] || { steps: [] };
    if (testMetaData && !testMetaData.steps) {
      testMetaData.steps = [];
    }
    testMetaData.steps?.push({
      id: step.id,
      text: step.text,
      keyword: step.keyword,
      started_at: (/* @__PURE__ */ new Date()).toISOString()
    });
    this._tests[uniqueId] = testMetaData;
  }
  async afterStep(step, scenario, result) {
    this._cucumberData.steps.pop();
    const uniqueId = getUniqueIdentifierForCucumber({ pickle: scenario });
    const testMetaData = this._tests[uniqueId] || { steps: [] };
    if (!testMetaData.steps) {
      testMetaData.steps = [{
        id: step.id,
        text: step.text,
        keyword: step.keyword,
        finished_at: (/* @__PURE__ */ new Date()).toISOString(),
        result: result.passed ? "PASSED" : "FAILED",
        duration: result.duration,
        failure: result.error ? removeAnsiColors(result.error) : result.error
      }];
    }
    const stepDetails = testMetaData.steps?.find((item) => item.id === step.id);
    if (stepDetails) {
      stepDetails.finished_at = (/* @__PURE__ */ new Date()).toISOString();
      stepDetails.result = result.passed ? "PASSED" : "FAILED";
      stepDetails.duration = result.duration;
      stepDetails.failure = result.error ? removeAnsiColors(result.error) : result.error;
    }
    this._tests[uniqueId] = testMetaData;
  }
  /**
   * misc methods
   */
  appendTestItemLog = async (stdLog) => {
    try {
      if (this._currentHook.uuid && !this._currentHook.finished && (this._framework === "mocha" || this._framework === "cucumber")) {
        stdLog.hook_run_uuid = this._currentHook.uuid;
      } else if (this._currentTest.uuid && (this._framework === "mocha" || this._framework === "cucumber")) {
        stdLog.test_run_uuid = this._currentTest.uuid;
      }
      if (stdLog.hook_run_uuid || stdLog.test_run_uuid) {
        this.listener.logCreated([stdLog]);
      }
    } catch (error) {
      BStackLogger.debug(`Exception in uploading log data to Observability with error : ${error}`);
    }
  };
  async browserCommand(commandType, args, test) {
    const dataKey = `${args.sessionId}_${args.method}_${args.endpoint}`;
    if (commandType === "client:beforeCommand") {
      this._commands[dataKey] = args;
      return;
    }
    if (!test) {
      return;
    }
    const identifier = this.getIdentifier(test);
    const testMeta = this._tests[identifier] || reporter_default.getTests()[identifier];
    if (!testMeta) {
      return;
    }
    const body = "body" in args ? args.body : void 0;
    const result = "result" in args ? args.result : void 0;
    if (Boolean(process.env[TESTOPS_SCREENSHOT_ENV]) && isScreenshotCommand(args) && result?.value) {
      await this.listener.onScreenshot([{
        test_run_uuid: testMeta.uuid,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        message: result.value,
        kind: "TEST_SCREENSHOT"
      }]);
    }
    const requestData = this._commands[dataKey];
    if (!requestData) {
      return;
    }
    this.listener.logCreated(
      [{
        test_run_uuid: testMeta.uuid,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        kind: "HTTP",
        http_response: {
          path: requestData.endpoint,
          method: requestData.method,
          body,
          response: result
        }
      }]
    );
  }
  /*
   * private methods
   */
  attachHookData(context, hookId) {
    if (context.currentTest && context.currentTest.parent) {
      const parentTest = `${context.currentTest.parent.title} - ${context.currentTest.title}`;
      if (!this._hooks[parentTest]) {
        this._hooks[parentTest] = [];
      }
      this._hooks[parentTest].push(hookId);
      return;
    } else if (context.test) {
      this.setHooksFromSuite(context.test.parent, hookId);
    }
  }
  setHooksFromSuite(parent, hookId) {
    if (!parent) {
      return false;
    }
    if (parent.tests && parent.tests.length > 0) {
      const uniqueIdentifier = getUniqueIdentifier(parent.tests[0], this._framework);
      if (!this._hooks[uniqueIdentifier]) {
        this._hooks[uniqueIdentifier] = [];
      }
      this._hooks[uniqueIdentifier].push(hookId);
      return true;
    }
    for (const suite of parent.suites) {
      const result = this.setHooksFromSuite(suite, hookId);
      if (result) {
        return true;
      }
    }
    return false;
  }
  /*
   * Get hierarchy info
   */
  getHierarchy(test) {
    const value = [];
    if (test.ctx && test.ctx.test) {
      let parent = typeof test.parent === "object" ? test.parent : test.ctx.test.parent;
      while (parent && parent.title !== "") {
        value.push(parent.title);
        parent = parent.parent;
      }
    } else if (test.description && test.fullName) {
      value.push(test.description);
      value.push(test.fullName.replace(new RegExp(" " + test.description + "$"), ""));
    }
    return value.reverse();
  }
  getRunData(test, eventType, results) {
    const fullTitle = getUniqueIdentifier(test, this._framework);
    const testMetaData = this._tests[fullTitle];
    const filename = test.file || this._suiteFile;
    this._currentTestId = testMetaData.uuid;
    const testData = {
      uuid: testMetaData.uuid,
      type: test.type || "test",
      name: test.title || test.description,
      body: {
        lang: "webdriverio",
        code: test.body
      },
      scope: fullTitle,
      scopes: this.getHierarchy(test),
      identifier: fullTitle,
      file_name: filename ? path13.relative(process.cwd(), filename) : void 0,
      location: filename ? path13.relative(process.cwd(), filename) : void 0,
      vc_filepath: this._gitConfigPath && filename ? path13.relative(this._gitConfigPath, filename) : void 0,
      started_at: testMetaData.startedAt,
      finished_at: testMetaData.finishedAt,
      result: "pending",
      framework: this._framework
    };
    if ((eventType === "TestRunFinished" || eventType === "HookRunFinished") && results) {
      const { error, passed } = results;
      if (!passed) {
        testData.result = error && error.message && error.message.includes("sync skip; aborting execution") ? "ignore" : "failed";
        if (error && testData.result !== "skipped") {
          testData.failure = [{ backtrace: [removeAnsiColors(error.message)] }];
          testData.failure_reason = removeAnsiColors(error.message);
          testData.failure_type = isUndefined(error.message) ? null : error.message.toString().match(/AssertionError/) ? "AssertionError" : "UnhandledError";
        }
      } else {
        testData.result = "passed";
      }
      testData.retries = results.retries;
      testData.duration_in_ms = results.duration;
      if (this._hooks[fullTitle]) {
        testData.hooks = this._hooks[fullTitle];
      }
    }
    if (eventType === "TestRunStarted" || eventType === "TestRunSkipped" || eventType === "HookRunStarted") {
      testData.integrations = {};
      if (this._browser && this._platformMeta) {
        const provider = getCloudProvider(this._browser);
        testData.integrations[provider] = this.getIntegrationsObject();
      }
    }
    if (eventType === "TestRunSkipped") {
      testData.result = "skipped";
      eventType = "TestRunFinished";
    }
    if (eventType.match(/HookRun/)) {
      testData.hook_type = testData.name?.toLowerCase() ? getHookType(testData.name.toLowerCase()) : "undefined";
      testData.test_run_id = this.getTestRunId(test.ctx);
    }
    return testData;
  }
  getTestRunId(context) {
    if (!context) {
      return;
    }
    if (context.currentTest) {
      const uniqueIdentifier = getUniqueIdentifier(context.currentTest, this._framework);
      return this._tests[uniqueIdentifier] && this._tests[uniqueIdentifier].uuid;
    }
    if (!context.test) {
      return;
    }
    return this.getTestRunIdFromSuite(context.test.parent);
  }
  getTestRunIdFromSuite(parent) {
    if (!parent) {
      return;
    }
    for (const test of parent.tests) {
      const uniqueIdentifier = getUniqueIdentifier(test, this._framework);
      if (this._tests[uniqueIdentifier]) {
        return this._tests[uniqueIdentifier].uuid;
      }
    }
    for (const suite of parent.suites) {
      const testRunId = this.getTestRunIdFromSuite(suite);
      if (testRunId) {
        return testRunId;
      }
    }
    return;
  }
  getTestRunDataForCucumber(worldObj, eventType, testMetaData = null) {
    const world = worldObj;
    const dataHub = testMetaData ? testMetaData : this._tests[getUniqueIdentifierForCucumber(world)] || {};
    const { feature, scenario, steps, uuid, startedAt, finishedAt } = dataHub;
    const examples = !testMetaData ? getScenarioExamples(world) : void 0;
    let fullNameWithExamples;
    if (!testMetaData) {
      fullNameWithExamples = examples ? world.pickle.name + " (" + examples.join(", ") + ")" : world.pickle.name;
    } else {
      fullNameWithExamples = scenario?.name || "";
    }
    this._currentTestId = uuid;
    const testData = {
      uuid,
      started_at: startedAt,
      finished_at: finishedAt,
      type: "test",
      body: {
        lang: "webdriverio",
        code: null
      },
      name: fullNameWithExamples,
      scope: fullNameWithExamples,
      scopes: [feature?.name || ""],
      identifier: scenario?.name,
      file_name: feature && feature.path ? path13.relative(process.cwd(), feature.path) : void 0,
      location: feature && feature.path ? path13.relative(process.cwd(), feature.path) : void 0,
      vc_filepath: this._gitConfigPath && feature?.path ? path13.relative(this._gitConfigPath, feature?.path) : void 0,
      framework: this._framework,
      result: "pending",
      meta: {
        feature,
        scenario,
        steps,
        examples
      }
    };
    if (eventType === "TestRunStarted" || eventType === "TestRunSkipped") {
      testData.integrations = {};
      if (this._browser && this._platformMeta) {
        const provider = getCloudProvider(this._browser);
        testData.integrations[provider] = this.getIntegrationsObject();
      }
    }
    if (world?.result) {
      let result = world.result.status.toLowerCase();
      if (result !== "passed" && result !== "failed") {
        result = "skipped";
      }
      testData.finished_at = (/* @__PURE__ */ new Date()).toISOString();
      testData.result = result;
      testData.duration_in_ms = world.result.duration.seconds * 1e3 + world.result.duration.nanos / 1e6;
      if (result === "failed") {
        testData.failure = [
          {
            "backtrace": [world.result.message ? removeAnsiColors(world.result.message) : "unknown"]
          }
        ];
        testData.failure_reason = world.result.message ? removeAnsiColors(world.result.message) : world.result.message;
        if (world.result.message) {
          testData.failure_type = world.result.message.match(/AssertionError/) ? "AssertionError" : "UnhandledError";
        }
      }
    }
    if (world?.pickle) {
      testData.tags = world.pickle.tags.map(({ name }) => name);
    }
    if (eventType === "TestRunSkipped") {
      testData.result = "skipped";
    }
    return testData;
  }
  async flushCBTDataQueue() {
    if (isUndefined(this._currentTestId)) {
      return;
    }
    this._cbtQueue.forEach((cbtData) => {
      cbtData.uuid = this._currentTestId;
      this.listener.cbtSessionCreated(cbtData);
    });
    this._currentTestId = void 0;
  }
  async sendCBTInfo() {
    const integrationsData = {};
    if (this._browser && this._platformMeta) {
      const provider = getCloudProvider(this._browser);
      integrationsData[provider] = this.getIntegrationsObject();
    }
    const cbtData = {
      uuid: "",
      integrations: integrationsData
    };
    if (this._currentTestId !== void 0) {
      cbtData.uuid = this._currentTestId;
      this.listener.cbtSessionCreated(cbtData);
    } else {
      this._cbtQueue.push(cbtData);
    }
  }
  getIntegrationsObject() {
    const caps = this._browser?.capabilities;
    const sessionId = this._browser?.sessionId;
    return {
      capabilities: caps,
      session_id: sessionId,
      browser: caps?.browserName,
      browser_version: caps?.browserVersion,
      platform: caps?.platformName,
      product: this._platformMeta?.product,
      platform_version: getPlatformVersion(this._userCaps)
    };
  }
  getIdentifier(test) {
    if ("pickle" in test) {
      return getUniqueIdentifierForCucumber(test);
    }
    return getUniqueIdentifier(test, this._framework);
  }
};
var InsightsHandler = o11yClassErrorHandler(_InsightsHandler);
var insights_handler_default = InsightsHandler;

// src/accessibility-handler.ts
import util3 from "node:util";
var _AccessibilityHandler = class {
  constructor(_browser, _capabilities, isAppAutomate, _framework, _accessibilityAutomation, _accessibilityOpts) {
    this._browser = _browser;
    this._capabilities = _capabilities;
    this._framework = _framework;
    this._accessibilityAutomation = _accessibilityAutomation;
    this._accessibilityOpts = _accessibilityOpts;
    const caps = this._browser.capabilities;
    this._platformA11yMeta = {
      browser_name: caps.browserName,
      // @ts-expect-error invalid caps property
      browser_version: caps?.browserVersion || caps?.version || "latest",
      os_name: this._getCapabilityValue(_capabilities, "os", "os"),
      os_version: this._getCapabilityValue(_capabilities, "osVersion", "os_version")
    };
    this._caps = _capabilities;
    this._accessibility = isTrue(_accessibilityAutomation);
    this._accessibilityOptions = _accessibilityOpts;
  }
  _platformA11yMeta;
  _caps;
  _suiteFile;
  _accessibility;
  _accessibilityOptions;
  _testMetadata = {};
  static _a11yScanSessionMap = {};
  _sessionId = null;
  setSuiteFile(filename) {
    this._suiteFile = filename;
  }
  _getCapabilityValue(caps, capType, legacyCapType) {
    if (caps) {
      if (capType === "accessibility") {
        if (caps["bstack:options"] && isTrue(caps["bstack:options"]?.accessibility)) {
          return caps["bstack:options"]?.accessibility;
        } else if (isTrue(caps["browserstack.accessibility"])) {
          return caps["browserstack.accessibility"];
        }
      } else if (capType === "deviceName") {
        if (caps["bstack:options"] && caps["bstack:options"]?.deviceName) {
          return caps["bstack:options"]?.deviceName;
        } else if (caps["bstack:options"] && caps["bstack:options"]?.device) {
          return caps["bstack:options"]?.device;
        } else if (caps["appium:deviceName"]) {
          return caps["appium:deviceName"];
        }
      } else if (capType === "goog:chromeOptions" && caps["goog:chromeOptions"]) {
        return caps["goog:chromeOptions"];
      } else {
        const bstackOptions = caps["bstack:options"];
        if (bstackOptions && bstackOptions?.[capType]) {
          return bstackOptions?.[capType];
        } else if (caps[legacyCapType]) {
          return caps[legacyCapType];
        }
      }
    }
  }
  async before(sessionId) {
    this._sessionId = sessionId;
    this._accessibility = isTrue(this._getCapabilityValue(this._caps, "accessibility", "browserstack.accessibility"));
    if (isBrowserstackSession(this._browser) && isAccessibilityAutomationSession(this._accessibility)) {
      const deviceName = this._getCapabilityValue(this._caps, "deviceName", "device");
      const chromeOptions = this._getCapabilityValue(this._caps, "goog:chromeOptions", "");
      this._accessibility = validateCapsWithA11y(deviceName, this._platformA11yMeta, chromeOptions);
    }
    this._browser.getAccessibilityResultsSummary = async () => {
      return await getA11yResultsSummary(this._browser, isBrowserstackSession(this._browser), this._accessibility);
    };
    this._browser.getAccessibilityResults = async () => {
      return await getA11yResults(this._browser, isBrowserstackSession(this._browser), this._accessibility);
    };
    this._browser.performScan = async () => {
      return await performA11yScan(this._browser, isBrowserstackSession(this._browser), this._accessibility);
    };
    if (!this._accessibility) {
      return;
    }
    if (!("overwriteCommand" in this._browser && Array.isArray(accessibility_scripts_default.commandsToWrap))) {
      return;
    }
    accessibility_scripts_default.commandsToWrap.filter((command) => command.name && command.class).forEach((command) => {
      const browser = this._browser;
      browser.overwriteCommand(command.name, this.commandWrapper.bind(this, command), command.class === "Element");
    });
  }
  async beforeTest(suiteTitle, test) {
    try {
      if (this._framework !== "mocha" || !this.shouldRunTestHooks(this._browser, this._accessibility)) {
        return;
      }
      const shouldScanTest = shouldScanTestForAccessibility(suiteTitle, test.title, this._accessibilityOptions);
      const testIdentifier = this.getIdentifier(test);
      const isPageOpened = await this.checkIfPageOpened(this._browser, testIdentifier, shouldScanTest);
      if (this._sessionId) {
        AccessibilityHandler._a11yScanSessionMap[this._sessionId] = shouldScanTest;
      }
      if (!isPageOpened) {
        return;
      }
      this._testMetadata[testIdentifier].accessibilityScanStarted = shouldScanTest;
      if (shouldScanTest) {
        BStackLogger.info("Automate test case execution has started.");
      }
    } catch (error) {
      BStackLogger.error(`Exception in starting accessibility automation scan for this test case ${error}`);
    }
  }
  async afterTest(suiteTitle, test) {
    BStackLogger.debug("Accessibility after test hook. Before sending test stop event");
    if (this._framework !== "mocha" || !this.shouldRunTestHooks(this._browser, this._accessibility)) {
      return;
    }
    try {
      const testIdentifier = this.getIdentifier(test);
      const accessibilityScanStarted = this._testMetadata[testIdentifier]?.accessibilityScanStarted;
      const shouldScanTestForAccessibility2 = this._testMetadata[testIdentifier]?.scanTestForAccessibility;
      if (!accessibilityScanStarted) {
        return;
      }
      if (shouldScanTestForAccessibility2) {
        BStackLogger.info("Automate test case execution has ended. Processing for accessibility testing is underway. ");
      }
      const dataForExtension = {
        saveResults: shouldScanTestForAccessibility2,
        testDetails: {
          "name": test.title,
          "testRunId": process.env.BS_A11Y_TEST_RUN_ID,
          "filePath": this._suiteFile,
          "scopeList": [suiteTitle, test.title]
        },
        platform: this._platformA11yMeta
      };
      await this.sendTestStopEvent(this._browser, dataForExtension);
      if (shouldScanTestForAccessibility2) {
        BStackLogger.info("Accessibility testing for this test case has ended.");
      }
    } catch (error) {
      BStackLogger.error(`Accessibility results could not be processed for the test case ${test.title}. Error : ${error}`);
    }
  }
  /**
    * Cucumber Only
  */
  async beforeScenario(world) {
    const pickleData = world.pickle;
    const gherkinDocument = world.gherkinDocument;
    const featureData = gherkinDocument.feature;
    const uniqueId = getUniqueIdentifierForCucumber(world);
    if (!this.shouldRunTestHooks(this._browser, this._accessibility)) {
      return;
    }
    try {
      const shouldScanScenario = shouldScanTestForAccessibility(featureData?.name, pickleData.name, this._accessibilityOptions, world, true);
      const isPageOpened = await this.checkIfPageOpened(this._browser, uniqueId, shouldScanScenario);
      if (this._sessionId) {
        AccessibilityHandler._a11yScanSessionMap[this._sessionId] = shouldScanScenario;
      }
      if (!isPageOpened) {
        return;
      }
      this._testMetadata[uniqueId].accessibilityScanStarted = shouldScanScenario;
      if (shouldScanScenario) {
        BStackLogger.info("Automate test case execution has started.");
      }
    } catch (error) {
      BStackLogger.error(`Exception in starting accessibility automation scan for this test case ${error}`);
    }
  }
  async afterScenario(world) {
    BStackLogger.debug("Accessibility after scenario hook. Before sending test stop event");
    if (!this.shouldRunTestHooks(this._browser, this._accessibility)) {
      return;
    }
    const pickleData = world.pickle;
    try {
      const gherkinDocument = world.gherkinDocument;
      const featureData = gherkinDocument.feature;
      const uniqueId = getUniqueIdentifierForCucumber(world);
      const accessibilityScanStarted = this._testMetadata[uniqueId]?.accessibilityScanStarted;
      const shouldScanTestForAccessibility2 = this._testMetadata[uniqueId]?.scanTestForAccessibility;
      if (!accessibilityScanStarted) {
        return;
      }
      if (shouldScanTestForAccessibility2) {
        BStackLogger.info("Automate test case execution has ended. Processing for accessibility testing is underway. ");
      }
      const dataForExtension = {
        saveResults: shouldScanTestForAccessibility2,
        testDetails: {
          "name": pickleData.name,
          "testRunId": process.env.BS_A11Y_TEST_RUN_ID,
          "filePath": gherkinDocument.uri,
          "scopeList": [featureData?.name, pickleData.name]
        },
        platform: this._platformA11yMeta
      };
      await this.sendTestStopEvent(this._browser, dataForExtension);
      if (shouldScanTestForAccessibility2) {
        BStackLogger.info("Accessibility testing for this test case has ended.");
      }
    } catch (error) {
      BStackLogger.error(`Accessibility results could not be processed for the test case ${pickleData.name}. Error : ${error}`);
    }
  }
  /*
   * private methods
   */
  async commandWrapper(command, origFunction, ...args) {
    if (this._sessionId && AccessibilityHandler._a11yScanSessionMap[this._sessionId] && (!command.name.includes("execute") || !AccessibilityHandler.shouldPatchExecuteScript(args.length ? args[0] : null))) {
      BStackLogger.debug(`Performing scan for ${command.class} ${command.name}`);
      await performA11yScan(this._browser, true, true, command.name);
    }
    return origFunction(...args);
  }
  async sendTestStopEvent(browser, dataForExtension) {
    BStackLogger.debug("Performing scan before saving results");
    await performA11yScan(browser, true, true);
    const results = await browser.executeAsync(accessibility_scripts_default.saveTestResults, dataForExtension);
    BStackLogger.debug(util3.format(results));
  }
  getIdentifier(test) {
    if ("pickle" in test) {
      return getUniqueIdentifierForCucumber(test);
    }
    return getUniqueIdentifier(test, this._framework);
  }
  shouldRunTestHooks(browser, isAccessibility) {
    if (!browser) {
      return false;
    }
    return isBrowserstackSession(browser) && isAccessibilityAutomationSession(isAccessibility);
  }
  async checkIfPageOpened(browser, testIdentifier, shouldScanTest) {
    let pageOpen = false;
    this._testMetadata[testIdentifier] = {
      scanTestForAccessibility: shouldScanTest,
      accessibilityScanStarted: true
    };
    try {
      const currentURL = await browser.getUrl();
      const url3 = new URL(currentURL);
      pageOpen = url3?.protocol === "http:" || url3?.protocol === "https:";
    } catch (e) {
      pageOpen = false;
    }
    return pageOpen;
  }
  static shouldPatchExecuteScript(script) {
    if (!script || typeof script !== "string") {
      return true;
    }
    return script.toLowerCase().indexOf("browserstack_executor") !== -1 || script.toLowerCase().indexOf("browserstack_accessibility_automation_script") !== -1;
  }
};
var AccessibilityHandler = o11yClassErrorHandler(_AccessibilityHandler);
var accessibility_handler_default = AccessibilityHandler;

// src/Percy/PercyCaptureMap.ts
var PercyCaptureMap = class {
  #map = {};
  increment(sessionName, eventName) {
    if (!this.#map[sessionName]) {
      this.#map[sessionName] = {};
    }
    if (!this.#map[sessionName][eventName]) {
      this.#map[sessionName][eventName] = 0;
    }
    this.#map[sessionName][eventName]++;
  }
  decrement(sessionName, eventName) {
    if (!this.#map[sessionName] || !this.#map[sessionName][eventName]) {
      return;
    }
    this.#map[sessionName][eventName]--;
  }
  getName(sessionName, eventName) {
    return `${sessionName}-${eventName}-${this.get(sessionName, eventName)}`;
  }
  get(sessionName, eventName) {
    if (!this.#map[sessionName]) {
      return 0;
    }
    if (!this.#map[sessionName][eventName]) {
      return 0;
    }
    return this.#map[sessionName][eventName] - 1;
  }
};
var PercyCaptureMap_default = PercyCaptureMap;

// src/Percy/PercySDK.ts
var PercySDK_exports = {};
__export(PercySDK_exports, {
  screenshot: () => screenshot,
  screenshotApp: () => screenshotApp,
  snapshot: () => snapshot
});
var tryRequire = async function(pkg, fallback) {
  try {
    return (await import(pkg)).default;
  } catch {
    return fallback;
  }
};
var percySnapshot = await tryRequire("@percy/selenium-webdriver", null);
var percyAppScreenshot = await tryRequire("@percy/appium-app", {});
var snapshotHandler = (...args) => {
  PercyLogger.error("Unsupported driver for percy");
};
if (percySnapshot) {
  snapshotHandler = (browser, name) => {
    if (process.env.PERCY_SNAPSHOT === "true") {
      return percySnapshot(browser, name);
    }
  };
}
var snapshot = snapshotHandler;
var screenshotHandler = async (...args) => {
  PercyLogger.error("Unsupported driver for percy");
};
if (percySnapshot && percySnapshot.percyScreenshot) {
  screenshotHandler = percySnapshot.percyScreenshot;
}
var screenshot = screenshotHandler;
var screenshotAppHandler = async (...args) => {
  PercyLogger.error("Unsupported driver for percy");
};
if (percyAppScreenshot) {
  screenshotAppHandler = percyAppScreenshot;
}
var screenshotApp = screenshotAppHandler;

// src/Percy/Percy-Handler.ts
var _PercyHandler = class {
  constructor(_percyAutoCaptureMode, _browser, _capabilities, _isAppAutomate, _framework) {
    this._percyAutoCaptureMode = _percyAutoCaptureMode;
    this._browser = _browser;
    this._capabilities = _capabilities;
    this._isAppAutomate = _isAppAutomate;
    this._framework = _framework;
    if (!_percyAutoCaptureMode || !CAPTURE_MODES.includes(_percyAutoCaptureMode)) {
      this._percyAutoCaptureMode = "auto";
    }
  }
  _testMetadata = {};
  _sessionName;
  _isPercyCleanupProcessingUnderway = false;
  _percyScreenshotCounter = 0;
  _percyDeferredScreenshots = [];
  _percyScreenshotInterval = null;
  _percyCaptureMap;
  _setSessionName(name) {
    this._sessionName = name;
  }
  async teardown() {
    await new Promise((resolve) => {
      setInterval(() => {
        if (this._percyScreenshotCounter === 0) {
          resolve();
        }
      }, 1e3);
    });
  }
  async percyAutoCapture(eventName, sessionName) {
    try {
      if (eventName) {
        if (!sessionName) {
          this._percyScreenshotCounter += 1;
        }
        this._percyCaptureMap?.increment(sessionName ? sessionName : this._sessionName, eventName);
        await (this._isAppAutomate ? screenshotApp(this._percyCaptureMap?.getName(sessionName ? sessionName : this._sessionName, eventName)) : await screenshot(this._browser, this._percyCaptureMap?.getName(sessionName ? sessionName : this._sessionName, eventName)));
        this._percyScreenshotCounter -= 1;
      }
    } catch (err) {
      this._percyScreenshotCounter -= 1;
      this._percyCaptureMap?.decrement(sessionName ? sessionName : this._sessionName, eventName);
      PercyLogger.error(`Error while trying to auto capture Percy screenshot ${err}`);
    }
  }
  async before() {
    this._percyCaptureMap = new PercyCaptureMap_default();
  }
  deferCapture(sessionName, eventName) {
    this._percyScreenshotCounter += 1;
    this._percyDeferredScreenshots.push({ sessionName, eventName });
  }
  isDOMChangingCommand(args) {
    return typeof args.method === "string" && typeof args.endpoint === "string" && (args.method === "POST" && (PERCY_DOM_CHANGING_COMMANDS_ENDPOINTS.includes(args.endpoint) || /* click / clear element */
    args.endpoint.includes("/session/:sessionId/element") && (args.endpoint.includes("click") || args.endpoint.includes("clear")) || /* execute script sync / async */
    args.endpoint.includes("/session/:sessionId/execute") && args.body?.script || /* Touch action for Appium */
    args.endpoint.includes("/session/:sessionId/touch")) || args.method === "DELETE" && args.endpoint === "/session/:sessionId");
  }
  async cleanupDeferredScreenshots() {
    this._isPercyCleanupProcessingUnderway = true;
    for (const entry of this._percyDeferredScreenshots) {
      await this.percyAutoCapture(entry.eventName, entry.sessionName);
    }
    this._percyDeferredScreenshots = [];
    this._isPercyCleanupProcessingUnderway = false;
  }
  async browserBeforeCommand(args) {
    try {
      if (!this.isDOMChangingCommand(args)) {
        return;
      }
      do {
        await sleep(1e3);
      } while (this._percyScreenshotInterval);
      this._percyScreenshotInterval = setInterval(async () => {
        if (!this._isPercyCleanupProcessingUnderway) {
          clearInterval(this._percyScreenshotInterval);
          await this.cleanupDeferredScreenshots();
          this._percyScreenshotInterval = null;
        }
      }, 1e3);
    } catch (err) {
      PercyLogger.error(`Error while trying to cleanup deferred screenshots ${err}`);
    }
  }
  async browserAfterCommand(args) {
    try {
      if (!args.endpoint || !this._percyAutoCaptureMode) {
        return;
      }
      let eventName = null;
      const endpoint = args.endpoint;
      if (endpoint.includes("click") && ["click", "auto"].includes(this._percyAutoCaptureMode)) {
        eventName = "click";
      } else if (endpoint.includes("screenshot") && ["screenshot", "auto"].includes(this._percyAutoCaptureMode)) {
        eventName = "screenshot";
      } else if (endpoint.includes("actions") && ["auto"].includes(this._percyAutoCaptureMode)) {
        if (args.body && args.body.actions && Array.isArray(args.body.actions) && args.body.actions.length && args.body.actions[0].type === "key") {
          eventName = "keys";
        }
      } else if (endpoint.includes("/session/:sessionId/element") && endpoint.includes("value") && ["auto"].includes(this._percyAutoCaptureMode)) {
        eventName = "keys";
      }
      if (eventName) {
        this.deferCapture(this._sessionName, eventName);
      }
    } catch (err) {
      PercyLogger.error(`Error while trying to calculate auto capture parameters ${err}`);
    }
  }
  async afterTest() {
    if (this._percyAutoCaptureMode && this._percyAutoCaptureMode === "testcase") {
      await this.percyAutoCapture("testcase", null);
    }
  }
  async afterScenario() {
    if (this._percyAutoCaptureMode && this._percyAutoCaptureMode === "testcase") {
      await this.percyAutoCapture("testcase", null);
    }
  }
};
var PercyHandler = o11yClassErrorHandler(_PercyHandler);
var Percy_Handler_default = PercyHandler;

// src/service.ts
var BrowserstackService = class {
  constructor(options, _caps, _config) {
    this._caps = _caps;
    this._config = _config;
    this._options = { ...DEFAULT_OPTIONS, ...options };
    this._config || (this._config = this._options);
    this._observability = this._options.testObservability;
    this._accessibility = this._options.accessibility;
    this._percy = process.env.BROWSERSTACK_PERCY === "true";
    this._percyCaptureMode = process.env.BROWSERSTACK_PERCY_CAPTURE_MODE;
    this._turboScale = this._options.turboScale;
    if (this._observability) {
      this._config.reporters?.push(reporter_default);
      if (process.env[PERF_MEASUREMENT_ENV]) {
        PerformanceTester.startMonitoring("performance-report-service.csv");
      }
    }
    if (process.env.BROWSERSTACK_TURBOSCALE) {
      this._turboScale = process.env.BROWSERSTACK_TURBOSCALE === "true";
    }
    process.env.BROWSERSTACK_TURBOSCALE_INTERNAL = String(this._turboScale);
    const strict = Boolean(this._config.cucumberOpts && this._config.cucumberOpts.strict);
    if (strict) {
      this._failureStatuses.push("pending");
    }
    if (process.env.WDIO_WORKER_ID === process.env.BEST_PLATFORM_CID) {
      process.env.PERCY_SNAPSHOT = "true";
    }
  }
  _sessionBaseUrl = "https://api.browserstack.com/automate/sessions";
  _failReasons = [];
  _scenariosThatRan = [];
  _failureStatuses = ["failed", "ambiguous", "undefined", "unknown"];
  _browser;
  _suiteTitle;
  _suiteFile;
  _fullTitle;
  _options;
  _specsRan = false;
  _observability;
  _currentTest;
  _insightsHandler;
  _accessibility;
  _accessibilityHandler;
  _percy;
  _percyCaptureMode = void 0;
  _percyHandler;
  _turboScale;
  _updateCaps(fn) {
    const multiRemoteCap = this._caps;
    if (multiRemoteCap.capabilities) {
      return Object.entries(multiRemoteCap).forEach(([, caps]) => fn(caps.capabilities));
    }
    return fn(this._caps);
  }
  beforeSession(config) {
    const testObservabilityOptions = this._options.testObservabilityOptions;
    if (!config.user && !(testObservabilityOptions && testObservabilityOptions.user)) {
      config.user = "NotSetUser";
    }
    if (!config.key && !(testObservabilityOptions && testObservabilityOptions.key)) {
      config.key = "NotSetKey";
    }
    this._config.user = config.user;
    this._config.key = config.key;
  }
  async before(caps, specs, browser) {
    this._browser = browser ? browser : globalThis.browser;
    if (!isBrowserstackSession(this._browser)) {
      try {
        await ai_handler_default.selfHeal(this._options, caps, this._browser);
      } catch (err) {
        if (this._options.selfHeal === true) {
          BStackLogger.warn(`Error while setting up self-healing: ${err}. Disabling healing for this session.`);
        }
      }
    }
    if (this._isAppAutomate()) {
      this._sessionBaseUrl = "https://api-cloud.browserstack.com/app-automate/sessions";
    }
    if (this._turboScale) {
      this._sessionBaseUrl = "https://api.browserstack.com/automate-turboscale/v1/sessions";
    }
    this._scenariosThatRan = [];
    if (this._browser) {
      if (this._percy) {
        this._percyHandler = new Percy_Handler_default(
          this._percyCaptureMode,
          this._browser,
          this._caps,
          this._isAppAutomate(),
          this._config.framework
        );
        this._percyHandler.before();
      }
      try {
        const sessionId = this._browser.sessionId;
        if (this._observability) {
          patchConsoleLogs();
          this._insightsHandler = new insights_handler_default(
            this._browser,
            this._config.framework,
            this._caps,
            this._options
          );
          await this._insightsHandler.before();
        }
        if (isBrowserstackSession(this._browser)) {
          try {
            this._accessibilityHandler = new accessibility_handler_default(
              this._browser,
              this._caps,
              this._isAppAutomate(),
              this._config.framework,
              this._accessibility,
              this._options.accessibilityOptions
            );
            await this._accessibilityHandler.before(sessionId);
          } catch (err) {
            BStackLogger.error(`[Accessibility Test Run] Error in service class before function: ${err}`);
          }
        }
        this._browser.on("command", async (command) => {
          if (this._observability) {
            this._insightsHandler?.browserCommand(
              "client:beforeCommand",
              Object.assign(command, { sessionId }),
              this._currentTest
            );
          }
          await this._percyHandler?.browserBeforeCommand(
            Object.assign(command, { sessionId })
          );
        });
        this._browser.on("result", (result) => {
          if (this._observability) {
            this._insightsHandler?.browserCommand(
              "client:afterCommand",
              Object.assign(result, { sessionId }),
              this._currentTest
            );
          }
          this._percyHandler?.browserAfterCommand(
            Object.assign(result, { sessionId })
          );
        });
      } catch (err) {
        BStackLogger.error(`Error in service class before function: ${err}`);
        if (this._observability) {
          CrashReporter.uploadCrashReport(`Error in service class before function: ${err}`, err && err.stack);
        }
      }
    }
    return await this._printSessionURL();
  }
  /**
   * Set the default job name at the suite level to make sure we account
   * for the cases where there is a long running `before` function for a
   * suite or one that can fail.
   * Don't do this for Jasmine because `suite.title` is `Jasmine__TopLevel__Suite`
   * and `suite.fullTitle` is `undefined`, so no alternative to use for the job name.
   */
  async beforeSuite(suite) {
    this._suiteTitle = suite.title;
    this._insightsHandler?.setSuiteFile(suite.file);
    this._accessibilityHandler?.setSuiteFile(suite.file);
    if (suite.title && suite.title !== "Jasmine__TopLevel__Suite") {
      await this._setSessionName(suite.title);
    }
  }
  async beforeHook(test, context) {
    if (this._config.framework !== "cucumber") {
      this._currentTest = test;
    }
    await this._insightsHandler?.beforeHook(test, context);
  }
  async afterHook(test, context, result) {
    await this._insightsHandler?.afterHook(test, result);
  }
  async beforeTest(test) {
    this._currentTest = test;
    let suiteTitle = this._suiteTitle;
    if (test.fullName) {
      const testSuiteName = test.fullName.slice(0, test.fullName.indexOf(test.description || "") - 1);
      if (this._suiteTitle === "Jasmine__TopLevel__Suite") {
        suiteTitle = testSuiteName;
      } else if (this._suiteTitle) {
        suiteTitle = getParentSuiteName(this._suiteTitle, testSuiteName);
      }
    }
    await this._setSessionName(suiteTitle, test);
    await this._setAnnotation(`Test: ${test.fullName ?? test.title}`);
    await this._insightsHandler?.beforeTest(test);
    await this._accessibilityHandler?.beforeTest(suiteTitle, test);
  }
  async afterTest(test, context, results) {
    this._specsRan = true;
    const { error, passed } = results;
    if (!passed) {
      this._failReasons.push(error && error.message || "Unknown Error");
    }
    await this._insightsHandler?.afterTest(test, results);
    await this._percyHandler?.afterTest();
    await this._accessibilityHandler?.afterTest(this._suiteTitle, test);
  }
  async after(result) {
    const { preferScenarioName, setSessionName, setSessionStatus } = this._options;
    if (preferScenarioName && this._scenariosThatRan.length === 1) {
      this._fullTitle = this._scenariosThatRan.pop();
    }
    if (setSessionStatus) {
      const hasReasons = this._failReasons.length > 0;
      await this._updateJob({
        status: result === 0 && this._specsRan ? "passed" : "failed",
        ...setSessionName ? { name: this._fullTitle } : {},
        ...result === 0 && this._specsRan ? {} : hasReasons ? { reason: this._failReasons.join("\n") } : {}
      });
    }
    await listener_default.getInstance().onWorkerEnd();
    await this._percyHandler?.teardown();
    this.saveWorkerData();
    if (process.env[PERF_MEASUREMENT_ENV]) {
      await PerformanceTester.stopAndGenerate("performance-service.html");
      PerformanceTester.calculateTimes([
        "onRunnerStart",
        "onSuiteStart",
        "onSuiteEnd",
        "onTestStart",
        "onTestEnd",
        "onTestSkip",
        "before",
        "beforeHook",
        "afterHook",
        "beforeTest",
        "afterTest",
        "uploadPending",
        "teardown",
        "browserCommand"
      ]);
    }
  }
  /**
   * For CucumberJS
   */
  async beforeFeature(uri, feature) {
    this._suiteTitle = feature.name;
    await this._setSessionName(feature.name);
    await this._setAnnotation(`Feature: ${feature.name}`);
    await this._insightsHandler?.beforeFeature(uri, feature);
  }
  /**
   * Runs before a Cucumber Scenario.
   * @param world world object containing information on pickle and test step
   */
  async beforeScenario(world) {
    this._currentTest = world;
    await this._insightsHandler?.beforeScenario(world);
    await this._accessibilityHandler?.beforeScenario(world);
    const scenarioName = world.pickle.name || "unknown scenario";
    await this._setAnnotation(`Scenario: ${scenarioName}`);
  }
  async afterScenario(world) {
    this._specsRan = true;
    const status = world.result?.status.toLowerCase();
    if (status !== "skipped") {
      this._scenariosThatRan.push(world.pickle.name || "unknown pickle name");
    }
    if (status && this._failureStatuses.includes(status)) {
      const exception = world.result && world.result.message || (status === "pending" ? `Some steps/hooks are pending for scenario "${world.pickle.name}"` : "Unknown Error");
      this._failReasons.push(exception);
    }
    await this._insightsHandler?.afterScenario(world);
    await this._percyHandler?.afterScenario();
    await this._accessibilityHandler?.afterScenario(world);
  }
  async beforeStep(step, scenario) {
    await this._insightsHandler?.beforeStep(step, scenario);
    await this._setAnnotation(`Step: ${step.keyword}${step.text}`);
  }
  async afterStep(step, scenario, result) {
    await this._insightsHandler?.afterStep(step, scenario, result);
  }
  async onReload(oldSessionId, newSessionId) {
    if (!this._browser) {
      return Promise.resolve();
    }
    const { setSessionName, setSessionStatus } = this._options;
    const hasReasons = this._failReasons.length > 0;
    const status = hasReasons ? "failed" : "passed";
    if (!this._browser.isMultiremote) {
      BStackLogger.info(`Update (reloaded) job with sessionId ${oldSessionId}, ${status}`);
    } else {
      const browserName = this._browser.instances.filter(
        (browserName2) => this._browser && this._browser.getInstance(browserName2).sessionId === newSessionId
      )[0];
      BStackLogger.info(`Update (reloaded) multiremote job for browser "${browserName}" and sessionId ${oldSessionId}, ${status}`);
    }
    BStackLogger.warn(`Session Reloaded: Old Session Id: ${oldSessionId}, New Session Id: ${newSessionId}`);
    await this._insightsHandler?.sendCBTInfo();
    if (setSessionStatus) {
      await this._update(oldSessionId, {
        status,
        ...setSessionName ? { name: this._fullTitle } : {},
        ...hasReasons ? { reason: this._failReasons.join("\n") } : {}
      });
    }
    this._scenariosThatRan = [];
    delete this._fullTitle;
    delete this._suiteFile;
    this._failReasons = [];
    await this._printSessionURL();
  }
  _isAppAutomate() {
    const browserDesiredCapabilities = this._browser?.capabilities ?? {};
    const desiredCapabilities = this._caps ?? {};
    return !!browserDesiredCapabilities["appium:app"] || !!desiredCapabilities["appium:app"] || !!desiredCapabilities["appium:options"]?.app;
  }
  _updateJob(requestBody) {
    return this._multiRemoteAction((sessionId, browserName) => {
      BStackLogger.info(
        browserName ? `Update multiremote job for browser "${browserName}" and sessionId ${sessionId}` : `Update job with sessionId ${sessionId}`
      );
      return this._update(sessionId, requestBody);
    });
  }
  _multiRemoteAction(action) {
    if (!this._browser) {
      return Promise.resolve();
    }
    if (!this._browser.isMultiremote) {
      return action(this._browser.sessionId);
    }
    const multiremotebrowser = this._browser;
    return Promise.all(
      multiremotebrowser.instances.filter((browserName) => {
        const cap = getBrowserCapabilities(multiremotebrowser, this._caps, browserName);
        return isBrowserstackCapability(cap);
      }).map((browserName) => action(multiremotebrowser.getInstance(browserName).sessionId, browserName))
    );
  }
  _update(sessionId, requestBody) {
    if (!isBrowserstackSession(this._browser)) {
      return Promise.resolve();
    }
    const sessionUrl = `${this._sessionBaseUrl}/${sessionId}.json`;
    BStackLogger.debug(`Updating Browserstack session at ${sessionUrl} with request body: `, requestBody);
    const encodedAuth = Buffer.from(`${this._config.user}:${this._config.key}`, "utf8").toString("base64");
    const headers = {
      "Content-Type": "application/json; charset=utf-8",
      Authorization: `Basic ${encodedAuth}`
    };
    if (this._turboScale) {
      return fetch(sessionUrl, {
        method: "PATCH",
        body: JSON.stringify(requestBody),
        headers
      });
    }
    return fetch(sessionUrl, {
      method: "PUT",
      body: JSON.stringify(requestBody),
      headers
    });
  }
  async _printSessionURL() {
    if (!this._browser || !isBrowserstackSession(this._browser)) {
      return Promise.resolve();
    }
    await this._multiRemoteAction(async (sessionId, browserName) => {
      const sessionUrl = `${this._sessionBaseUrl}/${sessionId}.json`;
      BStackLogger.debug(`Requesting Browserstack session URL at ${sessionUrl}`);
      let browserUrl;
      const encodedAuth = Buffer.from(`${this._config.user}:${this._config.key}`, "utf8").toString("base64");
      const headers = {
        "Content-Type": "application/json; charset=utf-8",
        Authorization: `Basic ${encodedAuth}`
      };
      if (this._turboScale) {
        const response = await fetch(sessionUrl, {
          method: "GET",
          headers
        });
        const res = response.clone();
        browserUrl = (await res.json()).url;
      } else {
        const response = await fetch(sessionUrl, {
          method: "GET",
          headers
        });
        const res = response.clone();
        browserUrl = (await res.json()).automation_session.browser_url;
      }
      if (!this._browser) {
        return;
      }
      const capabilities = getBrowserCapabilities(this._browser, this._caps, browserName);
      const browserString = getBrowserDescription(capabilities);
      BStackLogger.info(`${browserString} session: ${browserUrl}`);
    });
  }
  async _setSessionName(suiteTitle, test) {
    if (!this._options.setSessionName || !suiteTitle) {
      return;
    }
    let name = suiteTitle;
    if (this._options.sessionNameFormat) {
      name = this._options.sessionNameFormat(
        this._config,
        this._caps,
        suiteTitle,
        test?.title
      );
    } else if (test && !test.fullName) {
      const pre = this._options.sessionNamePrependTopLevelSuiteTitle ? `${suiteTitle} - ` : "";
      const post = !this._options.sessionNameOmitTestTitle ? ` - ${test.title}` : "";
      name = `${pre}${test.parent}${post}`;
    }
    this._percyHandler?._setSessionName(name);
    if (name !== this._fullTitle) {
      this._fullTitle = name;
      await this._updateJob({ name });
    }
  }
  _setAnnotation(data) {
    return this._executeCommand("annotate", { data, level: "info" });
  }
  async _executeCommand(action, args) {
    if (!this._browser || !isBrowserstackSession(this._browser)) {
      return Promise.resolve();
    }
    const cmd = { action, ...args ? { arguments: args } : {} };
    const script = `browserstack_executor: ${JSON.stringify(cmd)}`;
    if (this._browser.isMultiremote) {
      const multiRemoteBrowser = this._browser;
      return Promise.all(Object.keys(this._caps).map(async (browserName) => {
        const browser = multiRemoteBrowser.getInstance(browserName);
        return await browser.execute(script);
      }));
    }
    return await this._browser.execute(script);
  }
  saveWorkerData() {
    saveWorkerData({
      usageStats: usageStats_default.getInstance().getDataToSave()
    });
  }
};

// src/logReportingAPI.ts
import Transport2 from "winston-transport";
var LOG_LEVELS2 = {
  INFO: "INFO",
  ERROR: "ERROR",
  DEBUG: "DEBUG",
  TRACE: "TRACE",
  WARN: "WARN"
};
var logReportingAPI = class extends Transport2 {
  log(info, callback = void 0) {
    setImmediate(() => {
      this.emit("logged", info);
    });
    if (typeof info === "object") {
      this.logToTestOps(info.level || LOG_LEVELS2.INFO, info.message, false);
    } else {
      this.logToTestOps(LOG_LEVELS2.INFO, info);
    }
    if (callback && typeof callback === "function") {
      callback();
    }
  }
  logToTestOps = (level = LOG_LEVELS2.INFO, message = "", consoleLog = true) => {
    if (consoleLog) {
      consoleHolder[level.toLowerCase()](message);
    }
    process.emit(`bs:addLog:${process.pid}`, {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      level: level.toUpperCase(),
      message,
      kind: "TEST_LOG",
      http_response: {}
    });
  };
  /* Patching this would show user an extended trace on their cli */
  trace = (message) => {
    this.logToTestOps(LOG_LEVELS2.TRACE, message);
  };
  debug = (message) => {
    this.logToTestOps(LOG_LEVELS2.DEBUG, message);
  };
  info = (message) => {
    this.logToTestOps(LOG_LEVELS2.INFO, message);
  };
  warn = (message) => {
    this.logToTestOps(LOG_LEVELS2.WARN, message);
  };
  error = (message) => {
    this.logToTestOps(LOG_LEVELS2.ERROR, message);
  };
};
var logReportingAPI_default = logReportingAPI;

// src/log4jsAppender.ts
var BSTestOpsLogger = new logReportingAPI_default({});
function BSTestOpsLog4JSAppender(layout, timezoneOffset) {
  return (loggingEvent) => {
    BSTestOpsLogger.log({
      level: loggingEvent.level ? loggingEvent.level.levelStr : null,
      message: loggingEvent.data ? loggingEvent.data.join(" ") : null
    });
  };
}
var configure = (config, layouts) => {
  let layout = layouts.colouredLayout;
  if (config.layout) {
    layout = layouts.layout(config.layout.type, config.layout);
  }
  return BSTestOpsLog4JSAppender(layout, config.timezoneOffset);
};

// src/index.ts
var src_default = BrowserstackService;
var launcher = BrowserstackLauncherService;
var log4jsAppender = { configure };
var BStackTestOpsLogger = logReportingAPI_default;
var PercySDK = PercySDK_exports;
export {
  BStackTestOpsLogger,
  PercySDK,
  src_default as default,
  launcher,
  log4jsAppender
};
